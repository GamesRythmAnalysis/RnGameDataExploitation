---
title: "MR52 - Traitement, visualisation et analyse des mouvements de souris dans
  les jeux à recentrage, homogénéisation des résultats des données souris"
output:
  pdf_document:
    toc: no
    highlight: kate
  html_document:
    df_print: paged
    toc: yes
header-includes:
  - \usepackage{caption}
  - \usepackage{fancyhdr}
  - \pagestyle{fancy}
  - \fancyhead[LO,LE]{MR52 - A2022}
  - \fancyhead[LE,RO]{OBRECHT Cyril}
---

\newpage

\setcounter{tocdepth}{5}
\tableofcontents

\newpage
\listoffigures
\newpage

## Introduction

 Le jeu vidéo est un médium complexe, basé sur l'art de la vidéo, il doit déjà s'exprimer par le biais des images qu'il nous montre et du son qu'il émet. Cependant, le jeu vidéo n'est pas un film, il est interactif. Il serait simpliste de résumé l'émotion que génère les jeux vidéos que par leur visuel, scénario et bande sonore. Il nous transmet aussi un sens par la gestuelle qu'il nous faut exécuter pour le jouer, le jeu vidéo peut par exemple nous choquer en nous forçant à faire des actions que l'on réprouve moralement. De facto, le joueur n'est plus qu'un simple spectateur, mais devient acteur. Le jeu fait réfléchir, de manière évidente pour les "puzzles" ou les "points and clic", ou moins comme pour les jeux d'aventure où le joueur écrit son histoire. Que cette réflexion soit flagrante ou non, consciente ou non, elle finit par se traduire par une action, un clic, un mouvement de stick, un geste Wii mote en main. Cette action, qui a germé dans les neurones du joueur, est matérialisé par le biais de ses muscles pour finir transmise au jeu par un signal électrique, sous la forme d'information.

  Il est difficile, voir impossible, de capturer chaque partie du processus, observer quel neurone a choisi l'activation de quel muscle et quand. Mais il est possible de capturer le clic, l'information qu'il produit. Cette capture est aisée, tous nos jeux la font. Ce n'est qu'avec cette information que les jeux nous transmettent ce qu'ils veulent nous faire ressentir. La rythmanalyse est un procédé qui se propose d'analyser ce que le jeu voie du joueur, ce que le jeu demande au joueur de faire. Cette méthode permet de répondre à la question "qu'arrive-t-il si aux jeux vidéo, je retire la vidéo ?", là où la réponse à la question inverse est toute trouvée : le let's play.
Cette méthode occulte une grande partie des biais par lesquels le jeu s'exprime pour mieux analyser ce qui reste. Il est ainsi possible d'analyser avec rigueur les variations de gameplay interne au jeu, mais aussi de le comparer à d'autres. La rythmanalyse permet de mieux étudier ce qui différencie tant cet art des autres : les manières qu'ont les joueurs d'y jouer.

  Aucune méthode n'est parfaite, toutes peuvent être améliorées. Le médium du jeu vidéo n'est pas uniforme, il y a une pluralité de technologie et de manière d'interagir avec. Ceci produit des données hétérogènes qu'il faut traiter pour pouvoir les comparer et les afficher afin de les comprendre. Visualiser pour interpréter. L'une des manières pour le joueur d'interagir avec le jeu est par le biais de la souris. Cependant, certains jeux interagissent aussi avec cette souris, pour des raisons techniques. Cette interaction prend la forme d'un recentrage. Régulièrement, le jeu repositionne le curseur au centre qu'il a défini. Cette inférence du jeu dans la position de la souris est transparente pour le joueur, mais pas pour la rythmanalyse. En effet, ces recentrages effectués fréquemment par le jeu rendent les données très difficiles à exploiter. Si difficile que désactiver l'analyse de ses données a été préféré au risque de mal analyser le jeu. L'objectif de ce rapport est de revisiter ce problème épineux et de proposer une manière robuste d'analyser ces données.

\newpage

## Traitement des données recentrées

### Inspection des données

Cette section est dédiée à une inspection préliminaire des données. L'objectif est d’étudier la forme et la manière dont les données brutes se répartissent afin de mieux pouvoir les exploiter.
```{r include = FALSE}

rm(list=ls())

packages <- c("ggplot2", "gridExtra","RColorBrewer","treemapify","dplyr","data.table","rstudioapi","ggpubr","knitr")
if (length(setdiff(packages, rownames(installed.packages()))) > 0) {
  install.packages(setdiff(packages, rownames(installed.packages())))  
}

#chargement auto de tout les packages (evite q'un package manque a l'appel)
for(package in packages){
  library(package,character.only = T,warn.conflicts = F)
}

session <- list.files (path = "Data", pattern = ".zip") # Recuperer liste des fichiers .zip dans le repertoire de travail

source("RScripts/ImportScript.R")
import.script()

# on importe les donnees et dezippe les fichiers
ImportZip (paste("Data",session [101],sep="/"), 0, "max")

mouseData <- d.M[M.EVENEMENT == "mouse move",]
rm(d.K)
```
Le jeu de données choisi contient un total de `r length(d.M$M.XPOS)` entrées. Ici, seules les entrées représentant un mouvement de la souris sont nécessaires. Cela nous laisse un total de `r length(mouseData$M.XPOS)` entrées à exploiter.

Le graphique ci-dessous présente la répartition des différentes valeurs pour les coordonnées x et y du jeu de données étudié.


```{r echo=FALSE, fig.align="center", fig.width=10,out.width="100%"}

info_x <- summary(mouseData$M.XPOS)

histo_x <- ggplot(mouseData,aes(x = M.XPOS)) +
  geom_histogram(binwidth = ((info_x[6]-info_x[1])/10)) +
  ggtitle("Histograme des valeurs de X")

histo_x_75 <- ggplot(mouseData[mouseData$M.XPOS > info_x[2] & mouseData$M.XPOS < info_x[5],],aes(x = M.XPOS)) +
  geom_histogram(binwidth = ((info_x[5]-info_x[2])/10)) +
  ggtitle(strwrap("Histograme des valeurs de X comprisent entre en le 1er et 3ème quartile (75% des valeurs)", 50))

print(ggarrange(histo_x, histo_x_75,
          ncol = 2, nrow = 1))
```
\captionof{figure}{Répartition initiale de la composante X des coordonées}
```{r echo=FALSE, fig.align="center", fig.width=10,out.width="100%"}
info_y <- summary(mouseData$M.YPOS)

histo_y <- ggplot(mouseData,aes(x = M.YPOS)) +
  geom_histogram(binwidth = ((info_y[6]-info_y[1])/10)) +
  ggtitle("Histograme des valeurs de Y")

histo_y_75 <- ggplot(mouseData[mouseData$M.YPOS > info_y[2] & mouseData$M.YPOS < info_y[5],],aes(x = M.YPOS)) +
  geom_histogram(binwidth = ((info_y[5]-info_y[2])/10)) +
  ggtitle("Histograme des valeurs de Y\ncomprisent entre en le 1er et\n3ème quartile (75% des valeurs)")

print(ggarrange(histo_y, histo_y_75,
          ncol = 2, nrow = 1))
```
\captionof{figure}{Répartition initiale de la composante Y des coordonées}
\newpage
Un grand pic est présent que ce soit pour les X ou pour les Y. Une possible explication de ces pics serait que le logiciel de capture enregistre les mouvements de recentrage.


```{r}
count_x <- sort(table(mouseData$M.XPOS), decreasing = TRUE)
count_y <- sort(table(mouseData$M.YPOS), decreasing = TRUE)

count_xy <- sort(table(paste(mouseData$M.XPOS,mouseData$M.YPOS)), decreasing = TRUE)

max_xy <- count_xy[paste(names(count_x[1]),names(count_y[1]))]
xy_prop <- max_xy/ length(mouseData$M.XPOS)
```

Cependant, bien que les valeurs qui produisent ces pics sont compatibles avec cette hypothèse (`r names(count_y[1]) ` pour les Y et `r names(count_x[1])` pour les X) on peut observer qu'il y a très peu d'entrées correspondant à ces deux coordonnées en même temps. En effet, lorsque l'on prend le couple (X, Y) : `r max_xy` on obtient `r round(xy_prop*100,2)`% des entrées. Cela qui parait être bien peu de recentrage.<br/>
On peut donc aisément conclure de ces observations que le logiciel d'enregistrement n'enregistre pas, au moins pas toujours, les mouvements de recentrage causés par le jeu.

### Détection du centre
Dans cette section, une méthode, la plus fiable possible, pour trouver le centre du jeu sera élaborée. La fiabilité de cette méthode est cruciale, puisque si l'on se trompe ici, alors la totalité des résultats suivants, qui seront dépendants de cette valeur, seront inutilisables en pratique.<br/>
Il est tout d'abord important de remarquer qu'une méthode est déjà présente, on pourrait donc supposer qu'elle a déjà fait ces preuves et ainsi passer à la suite. Cependant, cette méthode a été mise au point avec l’objectif de servir l’ancienne méthode de retraitement de ces données. L’ancienne méthode visait à détecter les recentrages et estimer les mouvements du joueur afin d’obtenir des données qui seraient celles qui auraient été enregistrées si le jeu ne recentrait pas.

La solution présente consiste à prendre la valeur médiane des X et des Y comme étant les coordonnées du centre. Cette méthode a besoin, pour fonctionner, que les mouvements soient globalement répartis de manière équivalente entre la gauche et la droite, entre le bas et le haut, ou que le pic de valeur soit suffisamment prononcé pour absorber le décalage.

Une solution qui apparaît satisfaisante serait de prendre comme centre le milieu de l'écran. En effet, le logiciel de capture enregistre la taille de l'écran, il serait donc tout à fait faisable de récupérer cette valeur. Cette solution a cependant de nombreuses failles. La première est que toutes les versions du logiciel n'enregistraient pas cette valeur. Ceci signifie que les enregistrements plus anciens seraient lésés. On peut également remarquer que lorsque l'on a deux écrans, le logiciel n'enregistre les dimensions que d'un seul écran. Écran qui n'est pas forcément celui sur-lequel le jeu est. Enfin, il est par ailleurs important de noter que tout le monde ne joue pas tout le temps en plein écran, la barre des tâches et les contours de la fenêtre du jeu vont décaler le centre. Toutes ces raisons font que cette solution qui paraissait, de prime abord, parfaite est en réalité bien moins fiable que la solution présente.

À la vue de la taille des pics correspondant au centre, une autre solution pourrait être de prendre la valeur de ces pics comme valeur de centre. Pour que cette solution puisse être considérée comme fiable, il est nécessaire de comprendre pourquoi ces pics existent afin de savoir s'il s'agit d'un indicateur fiable. On peut distinguer deux hypothèses de travail : la première est que les recentrages sont détectés, la seconde est son opposée.

Bien qu'aucun enregistrement n'ait montré que le logiciel de capture enregistre les recentrages, il reste nécessaire de prendre en compte ce cas puisque rien ne prouve qu'il ne se produira jamais. Si jamais le logiciel capture les recentrages, alors, il y aura une proportion anormalement élevée de mouvement effectué en direction du centre. Ce surplus de mouvement vers le centre aura pour effet certain de produire un pic notable aux coordonnées correspondant au centre. On peut donc conclure que cette méthode sera fiable dans le cas où les recentrages sont enregistrés.

Si les recentrages ne sont pas enregistrés, il n'est pas possible d'assurer la présence des pics. On peut cependant aisément se convaincre qu'ils seront présents puisque chaque mouvement vers le haut augmentera la prépondérance de la valeur X centrale, de même, chaque mouvement vertical augmentera la prépondérance de la valeur Y centrale. La faille de cette méthode se trouve dans les mouvements diagonaux. En effet, si la majeure partie des mouvements effectués sont des diagonales, alors il y aura deux pics situés de part et d'autre de la valeur centrale.

Il est tout à fait possible en théorie de détecter ce cas de figure, il suffira donc de passer par la méthode des médianes pour obtenir une estimation des coordonnées du centre.

```{r}

get_center <- function(data){
  med <- median(data)
  maxs <- sort(table(data), decreasing = TRUE)
  
  if(med == as.integer(names(maxs[1])) ){
    return(med)
  }
  
  test <- as.integer(names(maxs))<med
  max_left <- maxs[test]
  max_right <- maxs[!test]
  if(max_right[1] > maxs[as.character(med)] & max_left[1]>maxs[as.character(med)]){
    if(min(max_right[1],max_left[1])/maxs[1] > 0.8){
      # Si les deux pics sont de taille comparable alors on as un creux au niveaux médiane.
      # La valeur médianne est alors ce qui ce rapproche le plus du centre 
      return(med)
    } else {
      # Si les deux pics ne sont pas comparable alors il semble plus probable que l'un des pics soit issus d'un bruit et
      # que la valeur maximal soit le vrai centre.
      return(as.integer(names(maxs[1])))
    }
  } else {
    # Toute les valeurs qui ce situe d'un coté de la médianne sont inférieure à la médianne.
    # Ceci signifie que le jeux force a toujours bouger dans la même direction. La méthode de la médianne n'est donc pas fiable dans ce cas de figure 
    return(as.integer(names(maxs[1])))
  }
  
}


center_x <- get_center(mouseData$M.XPOS)
center_y <- get_center(mouseData$M.YPOS)
```


### Nettoyage des données
Lorsque l'on travaille sur des données, il est toujours nécessaire de les nettoyer, de supprimer le superflu inintéressant pour la question que l'on traite, d'atténuer le bruit causé par l'imperfection du mode d'acquisition. Ces données ne font pas exceptions, il est nécessaire de retirer des entrées du jeu de données.

La première action qui sera prise est de retirer les doublons. Avant de chercher à les supprimer, nous allons tout d'abord les chercher et évaluer leur quantité.

```{r}
is_duplcate <- duplicated(rleid(mouseData$M.XPOS,mouseData$M.YPOS))
```

La fonction `rleid` génère un vecteur d'identifiant qui ne se répète que lorsque les valeurs de X et de Y sont les mêmes plusieurs fois d'affiler. Ceci nous permet de supprimer deux entrés consécutives pour une même coordonnée sans pour autant interdire la même coordonnée de revenir plus tard dans la liste.

On obtient ainsi que `r round(length(is_duplcate[is_duplcate])/length(is_duplcate)*100,2)`% des entrées sont des duplicatas. Cette valeur est bien importante. Il est peu probable qu'autant de données ne cache pas d'information utile. Afin de ne pas risquer de supprimer de l'information qui pourrait être utile plus tard (pour moi ou pour autrui) seule les doublons situer en milieux de chaîne comme sur l'exemple ci-dessous seront supprimés.

```{r echo=F,results='asis'}
olen <- length(mouseData$M.XPOS)

kable(data.table(X = c(960,960,960,961,961,961,961), Y = c(530,530,531,531,531,531,531),DUPLICATE=c(F,T,F,F,T,T,T),KEPT=c(T,T,T,T,F,F,T)))

```
```{r}
to_remove <- which(is_duplcate)
to_remove <- to_remove[is_duplcate[to_remove+1]]
mouseData <- mouseData[-to_remove,]
```

Cette opération aura supprimé `r round(length(to_remove)/olen*100,2)`% des entrées. Le vaste décalage entre cette valeur et la précédente laisse supposer que la majeure partie des doublons viennent seul. Il est possible que ces doublons soient des sous produits causé par le recentrage : j'effectue un mouvement vers le haut, après un déplacement d'un pixel le jeu recentre ma souris, le logiciel ne détecte pas ce recentrage, je continue mon mouvement et repasse par le même pixel que précédemment. Il est aussi possible que ces doublons soient des indicateurs de fin et début de mouvement.

Maintenant que les doublons ont été traités, nous allons chercher une méthode pour supprimer les données enregistrer hors du jeu. Par exemple lorsque l'on démarre ou arrête l'enregistrement.

La méthode actuelle pour supprimer ces données consiste à chercher un unique seuil tel que : la somme des coordonnées plus éloignée du centre que le seuil représente environ 15% des données. Ces 15% de données sont ensuite supprimées. Cette méthode a fait ces preuves, mais il est sans doute possible de faire mieux.

Deux défauts à la méthode actuelle peuvent être constatés. Le premier peut être sujet à débat : la méthode de sélection par seuil restreint à une zone carrée autour du centre. Il me parait plus naturel de restreindre à l'aide de la distance au centre. Le mouvement de la souris dans les jeux usant du recentrage est somme tout assez analogue à celui d'un stick d'une manette, aussi cela me parait plus logique d'utiliser une distance comme métrique sur laquelle appliquer un seuil. Le second défaut que j'observe est double : le seuil est très granuleux, mais aussi très limité. En effet, on considère des sauts de 20 pixels par 20 pixels (10 de part et d'autre du centre) mais surtout le seuil est limité à 50 pixels autour du centre. Cela, c'est jusqu'ici prouver suffisant avec les tests effectué sur des enregistrements provenant d'un moniteur en full HD. Cependant, rien n'indique que ce soit nécessairement le cas, entre autre, pour des jeux upscale sur des moniteurs en 4k.

La limite de 85% arbitraire pourrait être amélioré, mais aucune méthode efficace afin de raffiner cette valeur n'a été trouvée, aussi, nous continuerons avec cette stratégie faute de mieux.

La solution proposée est donc la suivante :

```{r}
mouseData$M.DISTANCE <- sqrt(
  (mouseData$M.XPOS - center_x) ^ 2 +
  (mouseData$M.YPOS - center_y) ^ 2
)

mouseData <- mouseData[mouseData$M.DISTANCE < quantile(mouseData$M.DISTANCE,.85),]
```
\newpage
Après nettoyage, les données peuvent de nouveaux être présentées sous la forme d'un graphique :

```{r echo=FALSE}

clean_data <- function(d.M){
  
  is_duplcate <- duplicated(rleid(d.M$M.XPOS,d.M$M.YPOS))
  to_remove <- which(is_duplcate)
  to_remove <- to_remove[is_duplcate[to_remove+1]]
  d.M <- d.M[-to_remove,]
  
  
  center_x <- get_center(d.M$M.XPOS)
  
  center_y <- get_center(d.M$M.YPOS)
  
  d.M$M.DISTANCE <- sqrt(
    (d.M$M.XPOS - center_x) ^ 2 +
    (d.M$M.YPOS - center_y) ^ 2
  )
  
  d.M <- d.M[d.M$M.DISTANCE < quantile(d.M$M.DISTANCE,.85),]
  
  return(d.M)
}

make_graph <- function(d.M) {
  
  info_x <- summary(d.M$M.XPOS)
  info_y <- summary(d.M$M.YPOS)
  
  center_x <- get_center(d.M$M.XPOS)
  
  center_y <- get_center(d.M$M.YPOS)
  
  select_x <- "1er-3ème quartile"
  select_y <- "1er-3ème quartile"
  
  if(info_x[5] - info_x[2] < 7){
    info_x[5] <- info_x[3] + 3
    info_x[2] <- info_x[3] - 3
    select_x <- "médiane +/- 3"
  }
  
  sub_x <- d.M[d.M$M.XPOS >= info_x[2] & d.M$M.XPOS <= info_x[5],]
  sub_x$isCenter <- sub_x$M.XPOS==center_x
  
  if(info_y[5] - info_y[2] < 7){
    info_y[5] <- info_y[3] + 3
    info_y[2] <- info_y[3] - 3
    select_y <- "médiane +/- 3"
  }
  
  sub_y <- d.M[d.M$M.YPOS >= info_y[2] & d.M$M.YPOS <= info_y[5],]
  sub_y$isCenter <- sub_y$M.YPOS==center_y

  histo_x <- ggplot(sub_x,aes(x = M.XPOS,fill= isCenter)) +
    geom_histogram(binwidth = 1) +
    ggtitle(paste("Histograme des valeurs de X com\n-prise entre ",select_x,sep=""))+
    scale_x_continuous(breaks = seq(min(sub_x$M.XPOS),max(sub_x$M.XPOS)))+ 
    theme(axis.text.x = element_text(angle = 45,  hjust=1))

  histo_y <- ggplot(sub_y,aes(x = M.YPOS,fill= isCenter)) +
    geom_histogram(binwidth = 1) +
    ggtitle(paste("Histograme des valeurs de Y com\n-prise entre ",select_y,sep=""))+
    scale_x_continuous(breaks = seq(min(sub_y$M.YPOS),max(sub_y$M.YPOS)))+ 
    theme(axis.text.x = element_text(angle = 45,  hjust=1))
  

  return(ggarrange(histo_x,histo_y))
  
}
```
```{r echo=FALSE, fig.align="center", fig.width=10,out.width="100%"}
make_graph(mouseData)
```

\captionof{figure}{Répartition des composante X et Y des coordonées après pré traitement.}

## Visualisation des données recentré
Dans cette section, nous allons produire une visualisation des données recentrer. Je me suis inspiré de la visualisation des données du D pad. L'idée, l'objectif est de visualiser les directions de mouvement privilégié durant la session.

Le graphique souhaité se compose donc plusieurs "part de gâteaux" dont la taille angulaire décrit la proportion du cercle qu'il représente et dont la hauteur est proportionnelle au nombre des points qu'il englobe.

Nous allons dans un premier temps transformer nos coordonnées en nombre complexe afin d'ensuite en récupérer l'argument. Cette valeur d'angle qui nous est renvoyé est comprise entre $[-pi;pi[$ ce qui n'est pas tout à fait pratique. Nous allons ainsi décaler ces résultats vers $[frac{pi}{8}; 2pi+frac{pi}{8}[$. Il suffit après cela de répartir les angles produits en huit groupes, un par arc de cercle.

Mathématiquement l'argument du complexe 0 est non défini, cepandant R concidère que l'argument de 0 est 0 malgré l'existance d'un symbole plus adapté à ce cas dans le langage. Il est donc important de retirer du calcule toute les coordonées qui sont égale au centre sans quoi un des axes véra sa valeur biaiser.

\newpage
```{r, out.height="30%", fig.asp="1", fig.align="center"}

cadrans <- 8:1

coords <- (mouseData$M.XPOS-center_x) +1i*(mouseData$M.YPOS-center_y)
coords <- coords[coords != 0]

coords <- Arg(coords)
coords[coords<pi/8] <- coords[coords<pi/8] + 2*pi

splited_data <- factor(length(coords),levels = cadrans)

d <- lapply(cadrans,function(c){
  splited_data[coords <= 2*pi*c/8 + pi/8] <<- c
})
rm(d)

splited_data <- data.frame(cadrans = splited_data)

ggplot(splited_data, aes(x = cadrans,color="dummy")) +
  coord_polar(direction=1,start=pi/2 - pi/8)+
  geom_bar(width = 1)+ 
  xlab("")+
  ylab("")+
  theme(legend.position = "none" , axis.text.y = element_blank() , axis.ticks = element_blank())+
  scale_color_manual(values=c("#000000"))

```
\captionof{figure}{Cadrant montrant la répartion des positions de la souris autour du centre. - Minecraft}

### Vérification des algorithmes

Lors de leurs productions, les algorithmes présentées ci-dessus ont été calibrés à l'aide de donnée synthétique. Cependant, cela n'assure en rien leur bon fonctionnement avec des données réel. Afin de tester leur bon fonctionnement, des jeux de données témoin ont été produits sur Minecraft, un enregistrement de mouvement gauche-droite, un second avec des mouvements haut-bas.

```{r echo=FALSE, out.height="30%", fig.asp="1", fig.align="center"}
ImportZip (paste("Data",session [104],sep="/"), 0, "max")

mouseData <- d.M[M.EVENEMENT == "mouse move",]
rm(d.K)

center_x <- get_center(mouseData$M.XPOS)
center_y <- get_center(mouseData$M.YPOS)

is_duplcate <- duplicated(rleid(mouseData$M.XPOS,mouseData$M.YPOS))

to_remove <- which(is_duplcate)
to_remove <- to_remove[is_duplcate[to_remove+1]]
mouseData <- mouseData[-to_remove,]

mouseData$M.DISTANCE <- sqrt(
  (mouseData$M.XPOS - center_x) ^ 2 +
  (mouseData$M.YPOS - center_y) ^ 2
)

mouseData <- mouseData[mouseData$M.DISTANCE < quantile(mouseData$M.DISTANCE,.85),]

cadrans <- 8:1

coords <- (mouseData$M.XPOS-center_x) +1i*(mouseData$M.YPOS-center_y)
coords <- coords[coords != 0]

coords <- Arg(coords)
coords[coords<pi/8] <- coords[coords<pi/8] + 2*pi

splited_data <- factor(length(coords),levels = cadrans)

d <- lapply(cadrans,function(c){
  splited_data[coords <= 2*pi*c/8 + pi/8] <<- c
})
rm(d)

splited_data <- data.frame(cadrans = splited_data)

ggplot(splited_data, aes(x = cadrans,color="dummy")) +
  coord_polar(direction=1,start=pi/2 - pi/8)+
  geom_bar(width = 1)+ 
  xlab("")+
  ylab("")+
  theme(legend.position = "none" , axis.text.y = element_blank() , axis.ticks = element_blank())+
  scale_color_manual(values=c("#000000"))
```
\captionof{figure}{Cadrant montrant la répartion des positions de la souris autour du centre. - Minecraft}
```{r echo=FALSE, out.height="30%", fig.asp="1", fig.align="center"}
ImportZip (paste("Data",session [105],sep="/"), 0, "max")

mouseData <- d.M[M.EVENEMENT == "mouse move",]

center_x <- get_center(mouseData$M.XPOS)
center_y <- get_center(mouseData$M.YPOS)

is_duplcate <- duplicated(rleid(mouseData$M.XPOS,mouseData$M.YPOS))

to_remove <- which(is_duplcate)
to_remove <- to_remove[is_duplcate[to_remove+1]]
mouseData <- mouseData[-to_remove,]

mouseData$M.DISTANCE <- sqrt(
  (mouseData$M.XPOS - center_x) ^ 2 +
  (mouseData$M.YPOS - center_y) ^ 2
)

mouseData <- mouseData[mouseData$M.DISTANCE < quantile(mouseData$M.DISTANCE,.85),]

cadrans <- 8:1

coords <- (mouseData$M.XPOS-center_x) +1i*(mouseData$M.YPOS-center_y)
coords <- coords[coords != 0]

coords <- Arg(coords)
coords[coords<pi/8] <- coords[coords<pi/8] + 2*pi

splited_data <- factor(length(coords),levels = cadrans)

d <- lapply(cadrans,function(c){
  splited_data[coords <= 2*pi*c/8 + pi/8] <<- c
})
rm(d)

splited_data <- data.frame(cadrans = splited_data)

ggplot(splited_data, aes(x = cadrans,color="dummy")) +
  coord_polar(direction=1,start=pi/2 - pi/8)+
  geom_bar(width = 1)+ 
  xlab("")+
  ylab("")+
  theme(legend.position = "none" , axis.text.y = element_blank() , axis.ticks = element_blank())+
  scale_color_manual(values=c("#000000"))
```
\captionof{figure}{Cadrant montrant la répartion des positions de la souris autour du centre. - Minecraft}
\hfill \linebreak
Les graphiques ci-dessus sont ceux attendus. La seconde phase de test des algorithmes est un test exhaustif sur autant de jeux de donnée que possible. Afin de réduire la durée du test à un temps raisonnable (moins de 30 minutes) un seul jeu de données par jeux aura été retenu. Le jeu de données conservé est toujours celui qui contient l'enregistrement le plus long. Les résultats de ce test, sont globalement positifs. Il reste néanmoins un problème à élucider. Certains jeux semble avoir quatre pixels comme centre, ce qui fausse les graphiques et empêche l'interprétation. Pour les jeux tels que The Talos Principle, il n'est pas possible de trouver la cause, en effet le moteur n'est pas open source. De plus il apparaitrait que ce jeu soit le seul qui ait été développer dessus. Il serait possible que Serious Sam4 et Serious Sam: Siberian Mayhem utilise aussi le serious engine 4, mais aucune source fiable sur le sujet n'as été trouvé. D'autres jeux présente ce problème tel que Kentuky Route Zero, My time at portia et d'autre utilisant unity. Unity est partiellement open source, mais une lecture approfondie du code n'as pas permis de trouver une explication. Un jeu première personne minimaliste a donc été produit afin de pouvoir récupérer des données en provenance du jeu. Ce test a été possible, car Unity propose une licence gratuite sous certaine condition. Le résultat de ce test montre que sous certaines conditions qui n'ont pas pu être isolés, le jeu change de centre. Les jeux avec le moteur Unity peuvent donc belle et bien avoir 4 centres.

```{r echo=FALSE, fig.align="center", fig.width=10,out.width="100%"}
ImportZip (paste("Data",session [102],sep="/"), 0, "max")
mouseData <- d.M[M.EVENEMENT == "mouse move",]
rm(d.K)


make_graph(clean_data(mouseData))
```
\captionof{figure}{Répartition des composante X et Y des coordonées après pré traitement. - My time at portia}
```{r echo=FALSE, out.height="30%", fig.asp="1", fig.align="center"}
bck <- mouseData
center_x <- get_center(mouseData$M.XPOS)
center_y <- get_center(mouseData$M.YPOS)

is_duplcate <- duplicated(rleid(mouseData$M.XPOS,mouseData$M.YPOS))

to_remove <- which(is_duplcate)
to_remove <- to_remove[is_duplcate[to_remove+1]]
mouseData <- mouseData[-to_remove,]

mouseData$M.DISTANCE <- sqrt(
  (mouseData$M.XPOS - center_x) ^ 2 +
  (mouseData$M.YPOS - center_y) ^ 2
)

mouseData <- mouseData[mouseData$M.DISTANCE < quantile(mouseData$M.DISTANCE,.85),]

cadrans <- 8:1

coords <- (mouseData$M.XPOS-center_x) +1i*(mouseData$M.YPOS-center_y)
coords <- coords[coords != 0]

coords <- Arg(coords)
coords[coords<pi/8] <- coords[coords<pi/8] + 2*pi

splited_data <- factor(length(coords),levels = cadrans)

d <- lapply(cadrans,function(c){
  splited_data[coords <= 2*pi*c/8 + pi/8] <<- c
})
rm(d)

splited_data <- data.frame(cadrans = splited_data)

mouseData <- bck

ggplot(splited_data, aes(x = cadrans,color="dummy")) +
  coord_polar(direction=1,start=pi/2 - pi/8)+
  geom_bar(width = 1)+ 
  xlab("")+
  ylab("")+
  theme(legend.position = "none" , axis.text.y = element_blank() , axis.ticks = element_blank())+
  scale_color_manual(values=c("#000000"))
```
\captionof{figure}{Cadrant montrant la répartion des positions de la souris autour du centre. - My time at portia}

\hfill \linebreak

Une amélioration de l'algorithme de détection de centre est donc nécessaire afin de corriger ce problème. La solution proposé est de séléctioner un des quatre centre comme le nouveaux centre. On décale ensuite toute les valeurs X plus grande que celle du centre vers cette valeur, on éffectue la même transformation sur les Y. Cette transformation permet de conserver globalement les tendances de mouvement tout en produisant un unique centre avec lequelle les algorythmes précédament produit fonctionne. L'implémentation de ce changement peut être trouver ci-dessous.
\clearpage
```{r}

get_center <- function(med,maxs) {
  if(med == as.integer(names(maxs[1])) ){
    return(med)
  }
  
  test <- as.integer(names(maxs))<med
  max_left <- maxs[test]
  max_right <- maxs[!test]
  if(max_right[1] > maxs[as.character(med)] & max_left[1]>maxs[as.character(med)]){
    if(min(max_right[1],max_left[1])/maxs[1] > 0.8){
      # Si les deux pics sont de taille comparable alors on as un creux au niveaux médiane.
      # La valeur médianne est alors ce qui ce rapproche le plus du centre 
      return(med)
    } else {
      # Si les deux pics ne sont pas comparable alors il semble plus probable que l'un des pics soit issus d'un bruit et
      # que la valeur maximal soit le vrai centre.
      return(as.integer(names(maxs[1])))
    }
  } else {
    # Toute les valeurs qui ce situe d'un coté de la médianne sont inférieure à la médianne.
    # Ceci signifie que le jeux force a toujours bouger dans la même direction. La méthode de la médianne n'est donc pas fiable dans ce cas de figure 
    return(as.integer(names(maxs[1])))
  }
}

get_centers <- function(data){
  
  maxs_x <- sort(table(data$M.XPOS), decreasing = TRUE)
  maxs_y <- sort(table(data$M.YPOS), decreasing = TRUE)
  
  if( # Les pics sont adjacents
    abs( as.integer(names(maxs_x[1])) - as.integer(names(maxs_x[2])) ) == 1 & 
    abs( as.integer(names(maxs_y[1])) - as.integer(names(maxs_y[2])) ) == 1
    ){
    # Les pics sont de taille comparable
    if ( maxs_x[2]/maxs_x[1] > 0.9 & maxs_y[2]/maxs_y[1] > 0.9 ){
      center_x = min(as.integer(names(maxs_x[1])),as.integer(names(maxs_x[2])))
      center_y = min(as.integer(names(maxs_y[1])),as.integer(names(maxs_y[2])))
      # Décalage des données pour compacter le centre sur 1 pixel
      
      data$M.XPOS[data$M.XPOS > center_x] <- data$M.XPOS[data$M.XPOS > center_x] - 1
      data$M.YPOS[data$M.YPOS > center_y] <- data$M.YPOS[data$M.YPOS > center_y] - 1
      
      return(c(center_x,center_y,data))
      
    }
  }
  center_x <- get_center(median(data$M.XPOS),maxs_x)
  center_y <- get_center(median(data$M.YPOS),maxs_y)
  
  return(c(center_x,center_y,data))
  
} 

```
```{r echo=FALSE}
clean_data <- function(d.M){
  
  is_duplcate <- duplicated(rleid(d.M$M.XPOS,d.M$M.YPOS))
  to_remove <- which(is_duplcate)
  to_remove <- to_remove[is_duplcate[to_remove+1]]
  d.M <- d.M[-to_remove,]
  
  
  data <- get_centers(d.M)
  
  d.M <- data.frame(data[c(-1,-2)])
  
  center_y <- data[[2]]
  center_x <- data[[1]]
  
  d.M$M.DISTANCE <- sqrt(
    (d.M$M.XPOS - center_x) ^ 2 +
    (d.M$M.YPOS - center_y) ^ 2
  )
  
  d.M <- d.M[d.M$M.DISTANCE < quantile(d.M$M.DISTANCE,.85),]
  
  return(d.M)
}

make_graph <- function(d.M) {
  
  info_x <- summary(d.M$M.XPOS)
  info_y <- summary(d.M$M.YPOS)
  
  data <- get_centers(d.M)
  
  d.M <- data.frame(data[c(-1,-2)])
  
  center_y <- data[[2]]
  center_x <- data[[1]]
  
  select_x <- "1er-3ème quartile"
  select_y <- "1er-3ème quartile"
  
  if(info_x[5] - info_x[2] < 7){
    info_x[5] <- info_x[3] + 3
    info_x[2] <- info_x[3] - 3
    select_x <- "médiane +/- 3"
  }
  
  sub_x <- d.M[d.M$M.XPOS >= info_x[2] & d.M$M.XPOS <= info_x[5],]
  sub_x$isCenter <- sub_x$M.XPOS==center_x
  
  if(info_y[5] - info_y[2] < 7){
    info_y[5] <- info_y[3] + 3
    info_y[2] <- info_y[3] - 3
    select_y <- "médiane +/- 3"
  }
  
  sub_y <- d.M[d.M$M.YPOS >= info_y[2] & d.M$M.YPOS <= info_y[5],]
  sub_y$isCenter <- sub_y$M.YPOS==center_y

  histo_x <- ggplot(sub_x,aes(x = M.XPOS,fill= isCenter)) +
    geom_histogram(binwidth = 1) +
    ggtitle(paste("Histograme des valeurs de X comprise\nentre ",select_x,sep=""))+
    scale_x_continuous(breaks = seq(min(sub_x$M.XPOS),max(sub_x$M.XPOS)))+ 
    theme(axis.text.x = element_text(angle = 45,  hjust=1))

  histo_y <- ggplot(sub_y,aes(x = M.YPOS,fill= isCenter)) +
    geom_histogram(binwidth = 1) +
    ggtitle(paste("Histograme des valeurs de Y comprise\nentre ",select_y,sep=""))+
    scale_x_continuous(breaks = seq(min(sub_y$M.YPOS),max(sub_y$M.YPOS)))+ 
    theme(axis.text.x = element_text(angle = 45,  hjust=1))
  

  return(ggarrange(histo_x,histo_y))
}

```
```{r echo=FALSE, fig.align="center", fig.width=10,out.width="100%"}
ImportZip (paste("Data",session [102],sep="/"), 0, "max")
mouseData <- d.M[M.EVENEMENT == "mouse move",]
rm(d.K)
make_graph(clean_data(mouseData))
```
\captionof{figure}{Répartition des composante X et Y des coordonées après pré traitement. - My time at portia}
```{r echo=FALSE, out.height="30%", fig.asp="1", fig.align="center"}
data <- get_centers(mouseData)
  
mouseData <- data.frame(data[c(-1,-2)])
  
center_y <- data[[2]]
center_x <- data[[1]]

is_duplcate <- duplicated(rleid(mouseData$M.XPOS,mouseData$M.YPOS))

to_remove <- which(is_duplcate)
to_remove <- to_remove[is_duplcate[to_remove+1]]
mouseData <- mouseData[-to_remove,]

mouseData$M.DISTANCE <- sqrt(
  (mouseData$M.XPOS - center_x) ^ 2 +
  (mouseData$M.YPOS - center_y) ^ 2
)

mouseData <- mouseData[mouseData$M.DISTANCE < quantile(mouseData$M.DISTANCE,.85),]

cadrans <- 8:1

coords <- (mouseData$M.XPOS-center_x) +1i*(mouseData$M.YPOS-center_y)
coords <- coords[coords != 0]

coords <- Arg(coords)
coords[coords<pi/8] <- coords[coords<pi/8] + 2*pi

splited_data <- factor(length(coords),levels = cadrans)

d <- lapply(cadrans,function(c){
  splited_data[coords <= 2*pi*c/8 + pi/8] <<- c
})
rm(d)

splited_data <- data.frame(cadrans = splited_data)

ggplot(splited_data, aes(x = cadrans,color="dummy")) +
  coord_polar(direction=1,start=pi/2 - pi/8)+
  geom_bar(width = 1)+ 
  xlab("")+
  ylab("")+
  theme(legend.position = "none" , axis.text.y = element_blank() , axis.ticks = element_blank())+
  scale_color_manual(values=c("#000000"))
```
\captionof{figure}{Cadrant montrant la répartion des positions de la souris autour du centre. - My time at portia}
\hfill \linebreak

Une fois ce problème corriger, le même test est effectuer une seconde fois. Les résultats de cette itération sont disponible en annexe. L’analyse de ces résultats n’as montré aucun autre problème avec la version actuelle du traitement des données.

## Homogénéisation des données souris

Dans cette section, un traitement de données a été élaboré afin de transformer les données souris non recentrer dans une forme compatible avec les algorithme et visualisation précédemment créer. La stratégie qui a été utilisée et un recentrage dynamique systématique. Chaque coordonnée est recentrée par rapport à la coordonnée précédente. Cela permet d'extraire l'information de direction et donc de produire le graphique ci-dessous.


```{r echo=FALSE}
ImportZip (paste("Data",session [103],sep="/"), 0, "max")

mouseData <- d.M[M.EVENEMENT == "mouse move",]
rm(d.K)

cadran <- function(data,nb.cadran=8){
  cadrans <- nb.cadran:1
  x<- data$M.XPOS
  y<- data$M.YPOS
  
  cx <- 0
  cy <- 0
  
  coords <- (x-cx) +1i*(y-cy)
  coords <- coords[coords != 0]
  
  coords <- Arg(coords)
  coords[coords<pi/nb.cadran] <- coords[coords<pi/nb.cadran] + 2*pi # de -pi;pi a pi/nb.cadran;2pi+pi/nb.cadran
  
  output <- factor(length(x),levels = cadrans)
  lapply(cadrans,function(c){
    output[coords <= 2*pi*c/nb.cadran + pi/nb.cadran] <<- c
  })
  
  polar <- data.frame(cadrans = output)
  polar <<-polar

  return(
    ggplot(polar, aes(x = cadrans,color="dummy")) +
      coord_polar(direction=1,start= pi/2 - pi/nb.cadran)+
      geom_bar(width = 1)+ 
      xlab("")+
      ylab("")+
      theme(legend.position = "none" , axis.text.y = element_blank() , axis.ticks = element_blank())+
      scale_color_manual(values=c("#000000"))
  )
}
```
\newpage
```{r, out.height="30%", fig.asp="1", fig.align="center"}
centred <- data.frame(
  M.XPOS = mouseData$M.XPOS[-1] - mouseData$M.XPOS[-length(mouseData$M.XPOS)],
  M.YPOS = mouseData$M.YPOS[-1] - mouseData$M.YPOS[-length(mouseData$M.YPOS)],
  M.TEMPS = mouseData$M.TEMPS[-1]
)

cadran(centred)
```
\captionof{figure}{Cadrant des positions de la souris par rapport a la position précédente. - Satisfactory}
\hfill \linebreak

Le problème d'homogénéisation est simple à résoudre, car toute la donnée nécessaire est présente dans l'enregistrement, là où pour les jeux de donnée recentrée, il manque des informations sur le centre et les recentrages.

## Mise en pratique

Cette section vise à mettre en pratique les algorithme produit jusqu'ici en conjonction avec ceux existant pour produire une analyse comparative de deux jeux.

### Brève présentation des jeux

#### Minecraft

\hfill \linebreak  Minecraft est un jeu sandbox où le joueur évolue dans un monde généré procéduralement. Crée à l'origine par le Suédois Markus Persson et sortis en 2011, ce jeu est encore régulièrement mis à jour avec du nouveau contenu. Le jeu prend le parti prit de la liberté et laisse les joueurs exprimer leur créativité par le biais de construction, de création d'aventure ou encore en élaborant des mécanismes plus ou moins complexe.

#### Satisfactory

\hfill \linebreak  Satisfactory est un factory builder dans un environnement ouvert en 3D. Développer par Coffee Stain Studios, Satisfactory est disponible en early access depuis 2019. Satisfactory propose une progression au joueur en lui demandant des ressources pour pouvoir débloquer de nouvelles usines, matériaux et procéder. Une partie non négligeable du jeu est basé sur l'exploration de la carte afin de trouver des gisements de ressource, mais aussi des emplacements pour construire ses usines. Le jeu offre une grande liberté quant à, comment et où faire ces usines. Que l'on aime les englober dans de joli bâtiment, ou goudronner toute la nature qui nous entoure pour y construire des autoroutes de convoyeur, votre seule limite et votre imagination.

### Pourquoi ces jeux ?
Ces deux jeux proposent un gameplay qui se rapproche : la construction, construire ces usines est le cœur de Statisfactory et il s'agit d'un des piliers de Minecraft. Ces deux jeux proposent un environnement en 3D et enfin, ils utilisent une technique différente pour capter les mouvements de souris du joueur. Minecraft recentre la souris alors que Satisfactory ne le fait pas. Leurs similarités mettent en exergue cette différence et tout ceci permettra au mieux de constater et de montrer ce dont est capable le fuit des sections précédentes.

### Méthode de l'analyse
La méthode pour analysée et comparée ces deux jeux respecte le schéma classique d'une rythmanalyse :

#### Enregistrement des données

 \hfill \linebreak  Avant de pouvoir analyser des données de jeux, il faut les capturer et pour les capturer, il faut un logiciel de capture. Le logiciel utilisé a été spécialement conçue pour la rythmanalyse et se nomme RNGames. Le logiciel permet de capturer les frappes clavier, les mouvements de souris, mais aussi les divers signaux produit par certain contrôleur. Les résultats produits sont enregistrés dans une suite de fichier CSV qui associe les différents événements à un temps. Ces événements peuvent par exemple représenter l'information "touche A enfoncer" ou "touche B relâcher" et bien d’autre. Ces fichiers CSV sont ensuite groupés et compressés dans une unique archive dédiée à la session de jeux.

Les enregistrements ont tous étés effectués par la même personne (moi-même), à divers moments de progression des jeux. Certain de ces enregistrements date d'avant le début de mon travail sur ce sujet, d'autre ont été réaliser spécialement pour celui-ci.

#### Traitement des données

\hfill \linebreak  Les données enregistrées peuvent être analysées grâce au logiciel de rythmanalyse et aux algorithmes issus des sections précédentes. Le logiciel dédié à la rythmanalyse propose plusieurs sorties, divers graphiques sont produit afin de présenter diverses répartitions soit au cours du temps, soit en moyenne tout au long de la session étudié. Il est par exemple possible de visualisé l'activité des appuis clavier aux cours du temps. Ceci permet, si l'on découpe ces sessions convenablement, d'observer la présence ou absence de schéma d'activité récurent dans des jeux comme Tetrice, don patchi et bien d'autre.
Ces graphiques permettent donc d'analyser une session en particulier. Le logiciel produit aussi une suite d'indicateur numérique qui permette de décrire plus globalement une session. Ces indicateurs variés sont principalement utilisés avec un grand nombre d'enregistrements pour essayer de déterminer si, le contrôle d'une variable non-capturer par le logiciel, ou plus subjective (niveaux du joueur, personnage utilisé, ...) à un impact significatif et remarquable sur un, plusieurs ou sur une combinaison de ces indicateurs.

### Comparaison rythmanalitique de Minecraft et Satisfactory

#### Clavier

 \hfill \linebreak Lorsque l'on compare ce qui a toujours été comparable, à savoir les appuis clavier, on obtient entre autres ces deux graphiques :

```{r echo=FALSE}
knitr::include_graphics("./Graphs/2020.05.09.OC.minecraft.TCHVAR.png")
knitr::include_graphics("./Graphs/2022.10.02.CO.Satisfactory.TCHVAR.png")
```
\captionof{figure}{Fréquence d'appuis par touche. - Minecraft - Satisfactory}

On remarque immédiatement que ces graphiques sont assez similaire. Une activité globalement modérément soutenue sur toute la durée de la session. La répartition des appuis est plutôt homogène entre les différentes touches et stable dans le temps. Deux creux sont présents sur le graphique dédié à Minecraft, mon hypothèse à ce sujet est soit une pose dans la session, soit une période d'AFK. L'AFK (away from keyboard) est une pratique qui a dévié de son sens originel. Si dans un premier temps cela servait à signifier à d’autre que l’on s'éloignait de son PC, elle permet aussi de désigner ces moments ou le joueur laisse le jeu tourner sans interagir avec lui. La pratique est commune sur Minecraft où il est parfois nécessaire de patienter pour que des ennemis apparaissent afin d'obtenir des ressources ou de l'expérience en quantité.
L'activité de la main gauche est de manière assez constante double dans les sessions Minecraft lorsque comparée aux sessions Satisfactory. Il semblerait que Minecraft demande plus de vigueur sur le clavier.

```{r echo=FALSE, out.width = "50%"}
knitr::include_graphics("./Graphs/2022.10.02.CO.Satisfactory.TCHDUR.png")
knitr::include_graphics("./Graphs/2022.10.02.CO.Satisfactory.TCHDURTOT.png")
```
\captionof{figure}{Durée moyenne et totale des appuis par touche. - Satisfactory}
```{r echo=FALSE, out.width = "50%"}
knitr::include_graphics("./Graphs/2020.05.09.OC.minecraft.TCHDUR.png")
knitr::include_graphics("./Graphs/2020.05.09.OC.minecraft.TCHDURTOT.png")
```
\captionof{figure}{Durée moyenne et totale des appuis par touche. - Minecraft}
Les graphiques ci-dessus nous présente la répartition de la durée moyenne et totale entre les touches. Avant de pouvoir lire convenablement ces graphiques, il est intéressant de noter que les touches utilisées pour l'enregistrement de Minecraft ne sont pas standards. En effet, j'utilise `TFGH` pour me déplacer, mon inventaire est placé sur W. Une fois cette information connue, on remarque que la majeure partie de l'activité du joueur dans les deux jeux se situe dans le mouvement. La touche `shift` dans Satisfactory permet d'effectuer des glissades, ce moyen de déplacement allié à des sauts est plus rapide que la marche. Par contre, la touche `controle` pour Minecraft n'as rien à voir avec les déplacements du joueur. La présence notable de cette touche dans les résultats n’est pas expliqué. La touche n’est liée à aucune action dans ma configuration et n’est pas assez proche sur le clavier d’autre touche pour supposer que deux touches aient été appuyer en même temps par mégarde.

Après avoir étudié ce que les données extraites du clavier peuvent nous apprendre, deux conclusions se présentent d'elle-même:
Minecraft est plus demandeur pour la main gauche en termes de fréquence d'appuis, mais les deux jeux ont la même dynamique d'un mouvement constant.

Ce résultat n'est en rien étonnant, car je sais que dans mon cas, je passe beaucoup de temps à effectuer des aller-retour, que ce soit sur Minecraft ou Satifactory. Je doute qu'une comparaison entre plusieurs joueurs puisse mettre en évidence des différences lier à une autre manière d'approcher ces deux jeux puisque quoique l'on fasse sur Minecraft ou Satisfactory, il est nécessaire de se déplacer pour le faire. Une étude plus pousser n'en serait pour autans pas inintéressants surtout si son résultat est contradictoire avec mon analyse.

#### Souris 

 \hfill \linebreak Les deux jeux se distinguent réellement lorsque l'on commence à regarder l'activité issue des clics de la souris :

```{r echo=FALSE, out.width = "50%"}
knitr::include_graphics("./Graphs/2020.05.09.OC.minecraft.MF.png")
knitr::include_graphics("./Graphs/2022.10.02.CO.Satisfactory.MF.png")
```
\captionof{figure}{Fréquence de clic par boutton. - Minecraft - Satisfactory}

En effet, Ce qui saute aux yeux dans un premier temps est l'allure en dent de scie des résultats issue de Satisfactory. Ces dents de scie montrent la différence entre l'étape de planification où l'on regarde son environnement, cherche le bon gisement, planifie la position possible des machines et l'étape de construction où l'on place tout ce qui a été planifier. L'activité sur Minecraft est plus diffuse, bien plus continue. Encore une fois, on remarque que Minecraft est plus demandeur dans la fréquence de ces appuis. Nous avons donc un jeu ou la réflexion prime, ou le temps passer à jouer est un temps à se questionner sur les choix à faire. Et, un autre ou les actions s'enchaine sans interruption dans un flot de clic et d'appuis sur les touches du clavier.

Cette différence constante dans la demande de ces jeux n'est pour moi pas entièrement due aux jeux eux même. En effet, j'ai accumulé bien plus d'heure sur Minecraft que sur Satifactory, ainsi certaine tâche ne demande plus de réflexion, il s'agit d'un automatisme ce qui accélère l'action. Je ne possède malheureusement pas de statistique précise sur mon activité sur Satisfactory mais je n'ai pas du joueur bien plus de 30 à 50 heures. Là où je cumule plus de 1000 heures pour Minecraft, sans compter le fait que tous les lanceurs n'enregistre pas le temps passé sur le jeu. Une analyse comparant les activité de personne experte et de débutant sur ces jeux permettrait de mieux discerner l'origine de cette différence.


```{r echo=FALSE, out.height="30%", fig.asp="1", fig.align="center"}
ImportZip (paste("Data",session [101],sep="/"), 0, "max")
mouseData <- d.M[M.EVENEMENT == "mouse move",]
rm(d.K)
data <- get_centers(mouseData)
  
mouseData <- data.frame(data[c(-1,-2)])
  
center_y <- data[[2]]
center_x <- data[[1]]

is_duplcate <- duplicated(rleid(mouseData$M.XPOS,mouseData$M.YPOS))

to_remove <- which(is_duplcate)
to_remove <- to_remove[is_duplcate[to_remove+1]]
mouseData <- mouseData[-to_remove,]

mouseData$M.DISTANCE <- sqrt(
  (mouseData$M.XPOS - center_x) ^ 2 +
  (mouseData$M.YPOS - center_y) ^ 2
)

mouseData <- mouseData[mouseData$M.DISTANCE < quantile(mouseData$M.DISTANCE,.85),]

cadrans <- 8:1

coords <- (mouseData$M.XPOS-center_x) +1i*(mouseData$M.YPOS-center_y)
coords <- coords[coords != 0]

coords <- Arg(coords)
coords[coords<pi/8] <- coords[coords<pi/8] + 2*pi

splited_data <- factor(length(coords),levels = cadrans)

d <- lapply(cadrans,function(c){
  splited_data[coords <= 2*pi*c/8 + pi/8] <<- c
})
rm(d)

splited_data <- data.frame(cadrans = splited_data)

ggplot(splited_data, aes(x = cadrans,color="dummy")) +
  coord_polar(direction=1,start=pi/2 - pi/8)+
  geom_bar(width = 1)+ 
  xlab("")+
  ylab("")+
  theme(legend.position = "none" , axis.text.y = element_blank() , axis.ticks = element_blank())+
  scale_color_manual(values=c("#000000"))

```
\captionof{figure}{Cadrant montrant la répartion des positions de la souris autour du centre. - Minecraft}
```{r echo=FALSE, out.height="30%", fig.asp="1", fig.align="center"}
ImportZip (paste("Data",session [103],sep="/"), 0, "max")
mouseData <- d.M[M.EVENEMENT == "mouse move",]
rm(d.K)
centred <- data.frame(
  M.XPOS = mouseData$M.XPOS[-1] - mouseData$M.XPOS[-length(mouseData$M.XPOS)],
  M.YPOS = mouseData$M.YPOS[-1] - mouseData$M.YPOS[-length(mouseData$M.YPOS)],
  M.TEMPS = mouseData$M.TEMPS[-1]
)

cadran(centred)
```
\captionof{figure}{Cadrant des positions de la souris par rapport a la position précédente. - Satisfactory}
\hfill \linebreak
Ces deux graphiques nous montre une horizontalité des mouvements, un grand balayage de gauche à droite dans les deux jeux. Ces mouvements montre que, malgré que l'on pourrait penser que Satifactory à une certaine verticalité dans le gameplay, le jeu est majoritairement horizontal. Le joueur passe plus de temps à tourner la tête qu'à regarder vers le ciel et ce que l'on soit sur Minecraft ou sur Satisfactory. Il est aisé de constater une plus faible diversité des mouvements lorsque l'on compare les deux graphiques. Cette absence de mouvements diagonaux dans Satisfactory provient du procédé qui crée le graphique. En effet, rare sont les mouvements qui sont assez véloces pour prendre de court le logiciel de capture et ainsi avoir le temps d'effectuer un mouvement composer. A contrario, les jeux usants de recentrage n'ont pas de raison de s'assurer d'être si rapide pour capturer le mouvement. D'une part, le jeu peut tout à fait s'accommoder d'une fréquence de capture plus raisonnable. D'autre part, contrairement au logiciel de capture, le jeu a beaucoup à faire entre deux captures de la position de la souris du joueur. On peut tout de même remarquer que les mouvements verticaux sont moins présents sur Satisfactory. Cette différence à mes yeux s'explique par le comportement du joueur : sur Minecraft, je construis un toit au-dessus de ma tête, sur Satifactory, le ciel me suffit. Ceci pose une nouvelle question : serait-il possible grâce à ce type d'analyse macroscopique du mouvement de différencier deux joueurs ?

## Conclusion

  Le traitement de données est toujours une tâche complexe dont les résultats sont difficilement prévisibles. L'analyse des données enregistrées donne un résultat satisfaisant, mais incomplet. En effet, la rythmanalyse se veut de permettre l'analyse de large corpus hors aucun indicateur numérique permettant cela ne fut produit. On remarquera malgré tout que la visualisation produite met en lumière un nouvel angle d'analyse, ce qui est encourageant pour une possible suite. 
L'analyse comparative succincte de Satisfactory et Minecraft a permis d'entrevoir ce nouvel angle d’analyse. Que ce soit pour étudier des différences entre joueur, niveaux ou jeux, cette nouvelle visualisation semble bien être un nouvel outil qui sera utile.

Les données produites par les jeux avec recentrage avaient toujours été traités comme uniforme, mais ce travail a montré le contraire. Des différences existent, puisque certains jeux semble avoir plusieurs centres. Bien que cette possibilité soit avérée sur les jeux Unity, il n'en est rien pour d'autres moteurs qui ne sont pas libres d'utilisation.

\newpage
## Bibliographie

### Jeux
Markus Persson.Minecraft. Stockholm : Mojang Studios, 18 novembre 2011. Disponible sur :  https://www.minecraft.net/fr-fr (consulté le 1 janvier 2023)

	
Coffee Stain Studios. Satisfactory : Coffee Stain Publishing, 19 mars 2019. Disponible sur : https://www.satisfactorygame.com/ (consulté le 1 janvier 2023)

### Logiciels

BOULMIER, Jérôme, CORTIER, Benoît. RNGames. v1.4.0. 25 avril 2016. Disponible sur : https://github.com/GamesRythmAnalysis/RNGames (consulté le 12 otcobre 2022)

CORTIER, Benoît, OBRECHT, Cyril, TRICLOT, Mathieu. RNGames data exploitation. 5.7. 18 mai 2022. Disponible sur : https://github.com/GamesRythmAnalysis/RnGameDataExploitation (consulté le 12 otcobre 2022)

Unity Technologies. Unity Hub. 3.4.1. Disponible sur : https://unity.com/fr/download (consulté le 8 novembre 2022)

### Sites

Minecraft. *Wikipédia* [en ligne]. 27 décembre 2022. Disponible sur : https://fr.wikipedia.org/wiki/Minecraft (consulté le 1 janvier 2023)

Kentucky Route Zero. *Wikipédia* [en ligne]. 26 septembre 2022. Disponible sur : https://fr.wikipedia.org/wiki/Kentucky_Route_Zero (consulté le 23 octobre 2022)

Croteam. Technologie - Croteam - Croteam. In : Official website Croteam [en ligne]. [sans date]. Disponible sur : http://www.croteam.com/technology/ (consulté le consulté le 23 octobre 2022)

GitHub -Unity-Technologies/UnityCsReference: Unity C# reference source code. In : GitHub: Let’s build from here · GitHub [en ligne]. [sans date]. Disponible sur https://github.com/Unity-Technologies/UnityCsReference (consulté le consulté le 25 octobre 2022)

Free 2D, 3D, VR, & AR software for cross-platform development of games and mobile apps. - Unity Store. In: Powerful 2D, 3D, VR, & AR software for cross-platform development of games and mobile apps [en ligne]. [sans date].  Disponible sur https://store.unity.com/products/unity-personal (consulté le consulté le 8 novembre 2022)

### Essais
TRICLOT, Mathieu, 2019. Les jeux vidéo en aveugle : essai de rythmanalyses [en ligne]. Amalion. [Consulté le 30 octobre 2022]. ISBN 978-2-35926-078-6. Disponible à l’adresse : https://halshs.archives-ouvertes.fr/halshs-02133676

