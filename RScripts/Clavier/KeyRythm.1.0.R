
key.rythm <- function(key,data){
  
  ## Un data frame vide pour recevoir les resultats
  results <- data.frame("down.time"=numeric(),"duration"=numeric(),"touche"=factor())
  down <- NULL
  
  ## On est oblige de passer par une boucle pour parser ligne par ligne
  for (i in 1:nrow(d.K)) {
    
    ## ignorer les lignes qui concernent une autre cle que la notre
    if (d.K[i,"K.TOUCHE"] != key) next
    
    ## Pour la bonne cle, si l'on rencontre un down, le stocker 
    ##(ainsi, si l'on rencontre deux down de suite, sans up entre les deux, 
    ##le premier sera effaee et seul le second comptera)
    if (d.K$K.EVENEMENT[i] == "Key Down") {
      down <- d.K[i,]
      next
    }
    
    ## Si l'on rencontre un up
    if (d.K$K.EVENEMENT[i] == "Key Up") {
      
      ## verifier si l'on a bien eu un down precedemment
      if (is.null(down)== FALSE) {
        
        ## Calculer la duree entre down et up
        duration <- d.K$K.TEMPS[i] - down$K.TEMPS
        down.time <- down$K.TEMPS
        
        ## creer une ligne de data frame avec nom de la cle, debut du down, temps du down
        ligne <- c(down.time,duration)
        
        ## la concatener avec les resultats precedents
        results <- rbind(results,ligne)
        
        ## vider le down (en cas de deux up consecutifs, au cas oe)
        down <- NULL}
      #if (is.null(down)== TRUE) { # Traiter erreur dans le cas oe on rencontre d'abord un Up (e negliger)
      else
      {
        duration <- NA
        down.time <- NA
        ligne <-c(down.time,duration)
        results <- rbind (results,ligne)
      }
    }
    
    ## ajouter une variable identifiant la cle pour fusion avec les resultats sur les autres cle
    results$touche <- key
    
  }
  names (results) <- c ("down.time","duration","touche")
  return(results)
}
