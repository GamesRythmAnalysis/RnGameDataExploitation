# Analyse Pad
# Fonction pour l'analyse du Pad Rythmanalyse

pad.main <- function (d.P,infobaz,graph) { #possibilite de repasser valfreq pour touches freq. en argument
  # button change et analog change ne changent pas selon systeme et langue
  # mais les designations ensuite changent ! Source de bugs
  # determiner les bons tests 
  
  # separer appuis : boutons
  codeDpad <- c ("Commande de pouce","pov")
  bout <- subset (d.P, (d.P$P.ANALOG == "button change" & !(d.P$P.TOUCHE %in% codeDpad)))
  bout$P.TOUCHE <- droplevels (bout$P.TOUCHE)
  
  # separer DPAD
  # On cherche le prochain 0 ? Et le reste est considere appui continu ...
  # Donc code commande de pouce pourrait suffire 
  dpad <- subset (d.P, d.P$P.ANALOG == "button change" & d.P$P.TOUCHE %in% codeDpad)
  dpad$P.TOUCHE <- droplevels (dpad$P.TOUCHE)
  
  # separer gachettes
  gach <- subset (d.P, d.P$P.ANALOG == "analog change" & grepl ("z",d.P$P.TOUCHE,ignore.case=TRUE) == TRUE)
  gach$P.TOUCHE <- droplevels (gach$P.TOUCHE)
  
  # separer mouvement des sticks (analogique, mais sans gachettes traitees comme boutons)
  stick <- subset (d.P, d.P$P.ANALOG == "analog change" & grepl ("z",d.P$P.TOUCHE,ignore.case=TRUE) == FALSE)
  stick$P.TOUCHE <- droplevels (stick$P.TOUCHE)
  
  # nrow (d.P) == nrow (bout)+nrow (dpad)+nrow (stick)+nrow(gach)
  
  # P.DuM # Duree en minute de l'activite pad
  P.DuS <- (max (d.P$P.TEMPS)-min (d.P$P.TEMPS))
  P.DuM <- P.DuS / 60
  
  buttonRythm <- pad.boutton.analyse(bout)
  
  
  buttonRythm <- buttonRythm[order(buttonRythm$down.time),]
  entreApp <- buttonRythm$down.time[-1] - buttonRythm$down.time[-nrow(buttonRythm)]
  resultats <- data.frame(
    P.durApMoy <- mean(buttonRythm$durApp),
    P.durApSD <- sd(buttonRythm$durApp),
    P.durApTot <- sum(buttonRythm$durApp),
    P.durEntreApMoy <- mean(entreApp),
    P.durEntreApSD <- sd(entreApp))
  
  return (resultats)
}
