# Analyse Pad
# Fonction pour l'analyse du Pad Rythmanalyse

AnalysePad <- function (d.P,infobaz,graph) { #possibilite de repasser valfreq pour touches freq. en argument
  # button change et analog change ne changent pas selon systeme et langue
  # mais les designations ensuite changent ! Source de bugs
  # determiner les bons tests 
  
  # separer appuis : boutons
  codeDpad <- c ("Commande de pouce","pov")
  bout <- subset (d.P, (d.P$P.ANALOG == "button change" & !(d.P$P.TOUCHE %in% codeDpad)))
  bout$P.TOUCHE <- droplevels (bout$P.TOUCHE)
  
  # separer DPAD
  # On cherche le prochain 0 ? Et le reste est considere appui continu ...
  # Donc code commande de pouce pourrait suffire 
  dpad <- subset (d.P, d.P$P.ANALOG == "button change" & d.P$P.TOUCHE %in% codeDpad)
  dpad$P.TOUCHE <- droplevels (dpad$P.TOUCHE)
  
  # separer gâchettes
  gach <- subset (d.P, d.P$P.ANALOG == "analog change" & grepl ("z",d.P$P.TOUCHE,ignore.case=TRUE) == TRUE)
  gach$P.TOUCHE <- droplevels (gach$P.TOUCHE)
  
  # separer mouvement des sticks (analogique, mais sans gâchettes traitees comme boutons)
  stick <- subset (d.P, d.P$P.ANALOG == "analog change" & grepl ("z",d.P$P.TOUCHE,ignore.case=TRUE) == FALSE)
  stick$P.TOUCHE <- droplevels (stick$P.TOUCHE)
  
  # nrow (d.P) == nrow (bout)+nrow (dpad)+nrow (stick)+nrow(gach)
  
  # P.DuM # Duree en minute de l'activite pad
  P.DuS <- (max (d.P$P.TEMPS)-min (d.P$P.TEMPS))
  P.DuM <- P.DuS / 60
  
  # BOUTONS
  # Recodage avec les noms appropries
  bout$P.TOUCHE <- as.character(bout$P.TOUCHE)
  bout$P.TOUCHE[bout$P.TOUCHE == "Bouton 0"] <- "A"
  bout$P.TOUCHE[bout$P.TOUCHE == "Bouton 1"] <- "B"
  bout$P.TOUCHE[bout$P.TOUCHE == "Bouton 2"] <- "X"
  bout$P.TOUCHE[bout$P.TOUCHE == "Bouton 3"] <- "Y"
  bout$P.TOUCHE[bout$P.TOUCHE == "Bouton 4"] <- "LB"
  bout$P.TOUCHE[bout$P.TOUCHE == "Bouton 5"] <- "RB"
  bout$P.TOUCHE[bout$P.TOUCHE == "Bouton 6"] <- "Select"
  bout$P.TOUCHE[bout$P.TOUCHE == "Bouton 7"] <- "Start"
  bout$P.TOUCHE[bout$P.TOUCHE == "Bouton 8"] <- "StickG"
  bout$P.TOUCHE[bout$P.TOUCHE == "Bouton 9"] <- "StickD"
  bout$P.TOUCHE <- as.factor(bout$P.TOUCHE)
  
  AnalyseTouches <- function (key)  {
    kpad <- subset (bout, bout$P.TOUCHE == key)
    nbapp <- nrow (subset (kpad, kpad$P.VALEUR == 1))
    pair <- (1:(nrow(kpad)/2))*2
    durapp <- mean (kpad$P.TEMPS[pair]-kpad$P.TEMPS[pair-1])
    durapptot <- sum (kpad$P.TEMPS[pair]-kpad$P.TEMPS[pair-1])
    durappSD <- sd (kpad$P.TEMPS[pair]-kpad$P.TEMPS[pair-1])
    entrapp <- mean (kpad$P.TEMPS[pair+1]-kpad$P.TEMPS[pair-1], na.rm = TRUE)
    entrappSD <- sd (kpad$P.TEMPS[pair+1]-kpad$P.TEMPS[pair-1], na.rm = TRUE)
    synth <- data.frame (P.TOUCHE = key, P.NbAppuis = nbapp,
                         P.TpMoyEntreAppuis = entrapp, P.TpSDEntreAppuis = entrappSD,
                         P.TpMoyAppui = durapp, P.DurAppuiTot = durapptot, P.TpSDAppui = durappSD)
  }
  
  rez <- lapply (levels (bout$P.TOUCHE), AnalyseTouches)
  rez <- do.call ("rbind",rez)
  
  timingappui <- subset (bout, bout$P.VALEUR == 1)[,c(2,4)]
  
  # GACHETTES
  # fonction pour detection des pics appuis et relaches
  # traiter separemment linux (-1;+1) et windows (0;+1)
  
  minmaxdetect <- function (gachG) {
    l <- nrow (gachG)
    pic <- data.frame (P.TEMPS=numeric(),P.VALEUR = numeric(),
                       P.UPDOWN = factor())
    for (i in (2:(nrow (gachG)-1))) {
      if ( (gachG$P.VALEUR[i] > gachG$P.VALEUR[i-1]) & (gachG$P.VALEUR[i] > gachG$P.VALEUR[i+1])){
        ligne <- cbind (gachG[i,],P.UPDOWN = "Haut")
        pic <- rbind(pic, ligne)
      }
    }

    bas <- data.frame (P.TEMPS=numeric(),P.VALEUR = numeric(), 
                       P.UPDOWN = factor ())
    for (i in (2:(nrow (gachG)-1))) {
      if ( (gachG$P.VALEUR[i] < gachG$P.VALEUR[i-1]) & (gachG$P.VALEUR[i] < gachG$P.VALEUR[i+1])){
        lignea <- cbind (gachG[i-1,],P.UPDOWN = "Bas")
        #   ligneb <- cbind (gachG[i,],P.UPDOWN = "Bas")
        lignec <- cbind (gachG[i+1,],P.UPDOWN = "Bas")
        bas <- rbind(bas, lignea,lignec)
      }
    }
    # reconstituer tableau des appuis haut et bas sur la gachette
    
    lignea <- cbind (gachG[1,],P.UPDOWN ="Bas")
    ligneb <- cbind (gachG[nrow(gachG),],P.UPDOWN ="Bas")
    picbas <- rbind (lignea,ligneb,pic,bas)
    picbas <- picbas [order(picbas$P.TEMPS),]
    
    # on nettoye les erreurs : haut successifs (rang 1, rang 2)
    poshaut <- grep ("Haut", picbas$P.UPDOWN)
    dumbH <- grep ("Haut",picbas$P.UPDOWN[poshaut+1])
    dumbH <- poshaut[dumbH]
    if (sum(dumbH) > 0) {picbas <- picbas[-dumbH,]}
    
    poshaut <- grep ("Haut", picbas$P.UPDOWN)
    dumbH <- grep ("Haut",picbas$P.UPDOWN[poshaut+2])
    dumbH <- poshaut[dumbH]
    if (sum(dumbH) > 0) {picbas <- picbas[-dumbH,]}
    
    return(picbas)
    
  }
  
  # linux ou windows
  if (nrow (gach) > 50) {
    win <- grepl ("Axe", gach$P.TOUCHE) # si TRUE win
    
    if (win[1]) {
      gachG <- subset (gach, gach$P.VALEUR > 0)  
      gachG <- data.frame (gachG$P.TEMPS,gachG$P.VALEUR)
      names (gachG) <- c("P.TEMPS","P.VALEUR")
      gachD <- subset (gach, gach$P.VALEUR < 0)
      gachD <- data.frame (gachD$P.TEMPS,abs(gachD$P.VALEUR))
      names (gachD) <- c("P.TEMPS","P.VALEUR")
    } else   {
      gachG <- subset (gach, gach$P.TOUCHE == "z")
      gachG <- data.frame (gachG$P.TEMPS,gachG$P.VALEUR)
      names (gachG) <- c("P.TEMPS","P.VALEUR")
      gachG$P.VALEUR <- (gachG$P.VALEUR+1)/2
      gachD <- subset (gach, gach$P.TOUCHE == "rz")
      gachD <- data.frame (gachD$P.TEMPS,gachD$P.VALEUR)
      names (gachD) <- c("P.TEMPS","P.VALEUR")
      gachD$P.VALEUR <- (gachD$P.VALEUR+1)/2
    }
    
    # On passe la fonction pour gachette gauche et droite 
    
    if (nrow(gachG) > 50){
      gauche <- minmaxdetect(gachG)
      gauche2<-gachette.pic.detect(gachG)
      print(gauche2)
      poshaut <- grep ("Haut", gauche$P.UPDOWN)
      P.NbApGachG <- length (poshaut)
      P.DurApGachG <- mean (gauche$P.TEMPS[poshaut+1]-gauche$P.TEMPS[poshaut-1])
      P.DurApTotGachG <- sum (gauche$P.TEMPS[poshaut+1]-gauche$P.TEMPS[poshaut-1])
      P.DurApGachGSD <- sd (gauche$P.TEMPS[poshaut+1]-gauche$P.TEMPS[poshaut-1])
      P.EntreApGacgG <- mean (gauche$P.TEMPS[poshaut[2:length (poshaut)]]-gauche$P.TEMPS[poshaut[1:(length (poshaut)-1)]])
      P.EntreApGacgGSD <- sd (gauche$P.TEMPS[poshaut[2:length (poshaut)]]-gauche$P.TEMPS[poshaut[1:(length (poshaut)-1)]])
      ligne <- data.frame (P.TOUCHE = "GachetteGauche", P.NbAppuis = P.NbApGachG,
                           P.TpMoyEntreAppuis = P.EntreApGacgG, P.TpSDEntreAppuis = P.EntreApGacgGSD,
                           P.TpMoyAppui = P.DurApGachG, P.DurAppuiTot = P.DurApTotGachG, P.TpSDAppui = P.DurApGachGSD)
      rez <- rbind(rez,ligne)  
      appuisG <- subset (gauche, P.UPDOWN == "Haut")
      appuisG <- data.frame (P.TOUCHE ="GachetteGauche", P.TEMPS = appuisG$P.TEMPS)
      timingappui <- rbind (timingappui, appuisG)
    }
    
    if (nrow(gachD) > 50){
      droite <- minmaxdetect(gachD)
      poshaut <- grep ("Haut", droite$P.UPDOWN)
      P.NbApGachD <- length (poshaut)
      P.DurApGachD <- mean (droite$P.TEMPS[poshaut+1]-droite$P.TEMPS[poshaut-1])
      P.DurApTotGachD <- sum (droite$P.TEMPS[poshaut+1]-droite$P.TEMPS[poshaut-1])
      P.DurApGachDSD <- sd (droite$P.TEMPS[poshaut+1]-droite$P.TEMPS[poshaut-1])
      P.EntreApGachD <- mean (droite$P.TEMPS[poshaut[2:length (poshaut)]]-droite$P.TEMPS[poshaut[1:(length (poshaut)-1)]])
      P.EntreApGachDSD <- sd (droite$P.TEMPS[poshaut[2:length (poshaut)]]-droite$P.TEMPS[poshaut[1:(length (poshaut)-1)]])
      ligne <- data.frame (P.TOUCHE = "GachetteDroite", P.NbAppuis = P.NbApGachD,
                           P.TpMoyEntreAppuis = P.EntreApGachD, P.TpSDEntreAppuis = P.EntreApGachDSD,
                           P.TpMoyAppui = P.DurApGachD, P.DurAppuiTot = P.DurApTotGachD, P.TpSDAppui = P.DurApGachDSD)
      rez <- rbind(rez,ligne)  
      appuisD <- subset (droite, P.UPDOWN == "Haut")
      appuisD <- data.frame (P.TOUCHE ="GachetteDroite", P.TEMPS = appuisD$P.TEMPS)
      timingappui <- rbind (timingappui, appuisD)
    }  
  }
  
  
  ## DPAD
  if (nrow (dpad) > 0){
    nbapp <- nrow (subset (dpad, dpad$P.VALEUR == 0))
    posZ <- grep ("TRUE",dpad$P.VALEUR == 0)
    entrapp <- mean (dpad$P.TEMPS[posZ[1:length(posZ)-1]+1]-dpad$P.TEMPS[posZ[1:length(posZ)-1]])
    entrappSD <- sd (dpad$P.TEMPS[posZ[1:length(posZ)-1]+1]-dpad$P.TEMPS[posZ[1:length(posZ)-1]])
    durapp <- mean (dpad$P.TEMPS[posZ[2:length(posZ)]]-dpad$P.TEMPS[posZ[1:length(posZ)-1]+1])
    durapptot <- sum (dpad$P.TEMPS[posZ[2:length(posZ)]]-dpad$P.TEMPS[posZ[1:length(posZ)-1]+1])
    durappSD <- sd (dpad$P.TEMPS[posZ[2:length(posZ)]]-dpad$P.TEMPS[posZ[1:length(posZ)-1]+1])
    ligne <- data.frame (P.TOUCHE = "DPAD", P.NbAppuis = nbapp,
                         P.TpMoyEntreAppuis = entrapp, P.TpSDEntreAppuis = entrappSD,
                         P.TpMoyAppui = durapp, P.DurAppuiTot = durapptot, P.TpSDAppui = durappSD)
    rez <- rbind(rez,ligne)
    timingappui <- rbind (timingappui, data.frame (P.TOUCHE = "DPAD", P.TEMPS = subset (dpad, P.VALEUR > 0)$P.TEMPS))
  }
  
  ## Nombre de touches utilisees
  ## Aise de reinteger ici la mesure alter. DPAD vu que appuis dans timingappui sont traites > 0
  P.NbTouches <- nrow (rez)
  P.NbAppuis <- sum (rez$P.NbAppuis)
  P.NbAppuisS <- P.NbAppuis / P.DuS
  valfreq <- 0.01 * P.NbAppuis
  P.NbTouchesFreq <- nrow (subset (rez, rez$P.NbAppuis > valfreq))
  
  ## Valeurs globales
  P.TpMoyEntreAppuis <- sum ((rez$P.NbAppuis*rez$P.TpMoyEntreAppuis),na.rm=TRUE)/P.NbAppuis
  P.TpSDEntreAppuis <- sum ((rez$P.NbAppuis*rez$P.TpSDEntreAppuis),na.rm=TRUE)/P.NbAppuis
  P.TpMoyAppui <- sum ((rez$P.NbAppuis*rez$P.TpMoyAppui),na.rm=TRUE)/P.NbAppuis
  P.TpSDAppui <- sum ((rez$P.NbAppuis*rez$P.TpSDAppui),na.rm=TRUE)/P.NbAppuis
  
  ## Valeurs touche la plus frequente (attention max engendre erreur si null)
  if (!is.null (rez$P.NbAppuis)) {
    P.ToucheFreq <- subset (rez, rez$P.NbAppuis == max (rez$P.NbAppuis))$P.TOUCHE
    P.ToucheFreq <- P.ToucheFreq[1]
    P.PropFreq <- (rez$P.NbAppuis[rez$P.TOUCHE==P.ToucheFreq]/P.NbAppuis)*100
    P.TpMoyEntreAppuisFreq <- rez$P.TpMoyEntreAppuis[rez$P.TOUCHE==P.ToucheFreq]	
    P.TpSDEntreAppuisFreq <- rez$P.TpSDEntreAppuis[rez$P.TOUCHE==P.ToucheFreq]	
    P.TpMoyAppuiFreq <- rez$P.TpMoyAppui[rez$P.TOUCHE==P.ToucheFreq]	
    P.TpSDAppuiFreq <- rez$P.TpSDAppui[rez$P.TOUCHE==P.ToucheFreq]
    
    if (graph == TRUE) {
      graphiques.pad.touches (timingappui,P.NbTouchesFreq, P.DuM, rez, infobaz)
    }
    
    
  } else 
  {
    P.ToucheFreq <- NA
    P.PropFreq <- NA
    P.TpMoyEntreAppuisFreq <- NA
    P.TpSDEntreAppuisFreq <- NA
    P.TpMoyAppuiFreq <- NA
    P.TpSDAppuiFreq <- NA
  }
  
  ## STICK
  # distintguer Stick gauche (Axe Y, Axe X) / Stick (Rotation Y, Rotation X)
  # sous linux : 
  
  stickG <- subset (stick, grepl ("r", stick$P.TOUCHE, ignore.case=TRUE) == FALSE)
  stickD <- subset (stick, grepl ("r", stick$P.TOUCHE, ignore.case=TRUE) == TRUE)
  
  # recreer les coordonnees x/y a chaque temps
  AnalyseStick <- function (stickdata) {
    
    condition <- grepl ("y",stickdata$P.TOUCHE,ignore.case =TRUE)
    Y <- ifelse (condition,stickdata$P.VALEUR,NA)
    Y <- c (0,Y)
    condition <- is.na (Y)
    for (i in 2:length(Y)){
      if (condition[i]){
        Y[i] <- Y[i-1]
      }
    }
    
    condition <- grepl ("y",stickdata$P.TOUCHE,ignore.case =TRUE)
    X <- ifelse (!condition,stickdata$P.VALEUR,NA)
    X <- c (0,X)
    condition <- is.na (X)
    for (i in 2:length(X)){
      if (condition[i]){
        X[i] <- X[i-1]
      }
    }
    
    stickXY <- data.frame (P.TEMPS=stickdata$P.TEMPS, X = X[-1], 
                           Y = Y[-1])
  }
  
  if (nrow(stickG)>100){
    stickG <- AnalyseStick(stickG)
    DifX <- stickG$X[2:length(stickG$X)] - stickG$X[1:length(stickG$X)-1]
    DifY <- stickG$Y[2:length(stickG$Y)] - stickG$Y[1:length(stickG$Y)-1]
    P.VitG <- sum (sqrt (DifX^2 +DifY^2)) / max (stickG$P.TEMPS)    
  } else 
  {P.VitG <- 0}
  
  if (nrow(stickD)>100){
    stickD <- AnalyseStick(stickD)
    DifX <- stickG$X[2:length(stickG$X)] - stickG$X[1:length(stickG$X)-1]
    DifY <- stickG$Y[2:length(stickG$Y)] - stickG$Y[1:length(stickG$Y)-1]
    P.VitD <- sum (sqrt (DifX^2 +DifY^2)) / max (stickD$P.TEMPS)    
  } else 
  {P.VitD <- 0}
  
  
  
  ##
  # stickData <- stickG
  ##
  
  if (graph == TRUE) {
    if (nrow(stickG)>100) {
      plotG<-plotStick (stickG,paste(infobaz,"\n","Mouvement Stick Gauche"),paste (infobaz,".LStick",".png", sep =""))
    }
    if (nrow(stickD)>100) {
      plotD <- plotStick (stickD,paste(infobaz,"\n","Mouvement Stick Droit"),paste (infobaz,".RStick",".png", sep =""))
    }
    
    if (exists("plotG", environment()) & exists ("plotD", environment())) {
      png (filename = paste (infobaz,".Sticks",".png", sep =""), width = 1500, height = 700)
      grid.arrange(plotG, plotD, nrow=1, ncol=2)
      dev.off()
    }
  }
  
  P.Vit = P.VitG + P.VitD
  
  ##
  # Plot DPAD
  ##
  if (graph == TRUE) {
    if (nrow (dpad) > 100) {
      plotdpad (dpad,infobaz)
    }
  }
  
  
  P.NbAppuis # Nombre total d'appuis
  P.DuM # Duree en minute de l'activite pad
  P.NbAppuisS # Appuis par seconde
  if (is.null (P.NbTouches)) {P.NbTouches<-0} # Nombre de touches utilisees
  if (is.null (P.NbTouchesFreq)) {P.NbTouchesFreq<-0} # Nombre de touches frequemment utilisees (enlever inf. a valfreq 1%)
  P.TpMoyEntreAppuis # Temps moyen entre appuis  
  P.TpSDEntreAppuis # Ecart-type
  P.TpMoyAppui # Duree moyenne d'un appui
  P.TpSDAppui # Ecart-type duree d'un appui
  P.Vit # vitesse moyenne cumulee des deplacements des sticks
  P.VitG # vitesse Stick gauche
  P.VitD # vitesse stick droit
  P.ToucheFreq
  P.TpMoyEntreAppuisFreq
  P.TpSDEntreAppuisFreq 
  P.TpMoyAppuiFreq
  P.TpSDAppuiFreq
  
  
  resultats <- data.frame(P.DuM,P.NbTouches,P.NbTouchesFreq,
                          P.NbAppuis,P.NbAppuisS,
                          P.TpMoyEntreAppuis,P.TpSDEntreAppuis, 
                          P.TpMoyAppui,P.TpSDAppui,
                          P.ToucheFreq,P.PropFreq,
                          P.TpMoyEntreAppuisFreq,P.TpSDEntreAppuisFreq, 
                          P.TpMoyAppuiFreq,P.TpSDAppuiFreq,
                          P.Vit,P.VitG,P.VitD)
  return (resultats)
}