# fonction de recentrage pour les donn√©es souris

# donneesouris <- d.M

recentrage <- function (donneesouris) {
  # On slectionne les valeurs situes autour de la mediane
  xCenter <- median (d.M$M.XPOS)
  yCenter <- median (d.M$M.YPOS)
  
  #On suprime tout ce qui as ?t? captur? hors du jeu (a refaire on ne s'adapte pas a la r?gion de capture du jeu)
  seuils <- seq(10,50,by=10)
  i<-1
  SUB<- subset (d.M, d.M$M.XPOS < xCenter+seuils[i] & d.M$M.XPOS > xCenter-seuils[i]
                & d.M$M.YPOS < yCenter+seuils[i] & d.M$M.YPOS > yCenter-seuils[i])
  
  while(i<length(seuils) & length(SUB$M.XPOS)/length(d.M$M.XPOS)<0.85){
    SUB<- subset (d.M, d.M$M.XPOS < xCenter+seuils[i] & d.M$M.XPOS > xCenter-seuils[i]
                  & d.M$M.YPOS < yCenter+seuils[i] & d.M$M.YPOS > yCenter-seuils[i])
    i <- i +1
  }
  
  
  seuil<-seuils[i]
  # On replace tout sur un point zero ...
  # Qui n'est malheureusement jamais le vrai centre
  # Du fait de la drive de la distribution
  SUB$M.XPOS<-SUB$M.XPOS - xCenter
  SUB$M.YPOS<-SUB$M.YPOS - yCenter
  
  #on regarde les moment ou les deux coordon? valent z?ros =>recentrement + fin de movement du joueur
  zxy <- (SUB$M.XPOS == 0 & SUB$M.YPOS == 0)
  i<-1
  while(i<length(SUB$M.XPOS) & !zxy[i]){#on cherche la premi?re fois ou ?a arrive
    i<-i+1
  }
  #on tronque les donn? pour commencer a un endroit bien propre
  
  
  SUB<-SUB[-(1:i),]
  zxy<-zxy[-(1:i)]
  
  Rxpos <- numeric(length(zxy)+1)
  Rypos <- numeric(length(zxy)+1)
  Zfol<-rep(TRUE,times=length(zxy)+1)
  
  #on recalcule les vecteur en prenant en compte les fin de mouvement des joueurs
  #et on cherche les fois ou il y as eux recentrage sans mouvement
  for(i in 1:length(zxy)){
    if (zxy[i]){
      Rxpos[i+1]<-SUB$M.XPOS[i]
      Rypos[i+1]<-SUB$M.YPOS[i]
      if(zxy[i-1]){
        Zfol[i]<-FALSE
      }
    }else{
      Rxpos[i+1]<-Rxpos[i]+SUB$M.XPOS[i]
      Rypos[i+1]<-Rypos[i]+SUB$M.YPOS[i]
    }
  }
  #on retire de la liste des mouvement les recentrage inutiles et le premier ?l?ment qui vaut 0
  
  SUB$M.XPOS<-Rxpos[-1]
  SUB$M.XPOS<-Rypos[-1]
  SUB<-SUB[Zfol,]
  zxy<-zxy[Zfol]
  
  if(config$Graph & config$MouseGraph){
    
    s<-sample(length(Rxpos),length(Rxpos)/10)
    
    p<-data.frame(Rxpos[s],Rypos[s])
    names(p)<-c("XPOS","YPOS")
    
    ggplot (p,aes (x=XPOS, y=YPOS)) +
      geom_point(colour ="lightblue", alpha =0.25) +
      stat_density2d(aes(alpha = ..level.., fill=..level..), bins = 15, geom = "polygon")+
      scale_alpha_continuous(guide = FALSE)+
      scale_fill_gradient(low = "green", high = "red") +
      geom_density2d (colour="black", bins = 15, alpha = 0.25)+
      ggtitle(paste(infobaz,"\n","Mouvement de la Souris |seuil:",seuil))
    
    ggsave (file = paste (infobaz,".MM",".png", sep =""),
            width = 125, height = 125, units = "mm")
    
    ggplot (p,aes (x=XPOS, y=YPOS)) +
      stat_density2d(aes(alpha = ..level.., fill=..level..), bins = 15, geom = "polygon")+
      scale_alpha_continuous(guide = FALSE)+
      scale_fill_gradient(low = "green", high = "red") +
      geom_density2d (colour="black", bins = 15, alpha = 0.25)+
      ggtitle(paste(infobaz,"\n","Mouvement de la Souris|seuil:",seuil))
    
    ggsave (file = paste (infobaz,".MMHO",".png", sep =""),
            width = 125, height = 125, units = "mm")
    
  }
  
  distance=numeric(length(SUB$M.XPOS))
  
  #on calcule les distance pour la vitesse donc on ignore les movement de recentrage
  
  for(i in 0:(length(SUB$M.XPOS)-2)){
    if(zxy[i+1]){
      distance[i]<-0
    }else{
      distance[i]<-sqrt((SUB$M.XPOS[i+1]-SUB$M.XPOS[i])^2+(SUB$M.YPOS[i+1]-SUB$M.YPOS[i])^2)
    }
  }
  
  M.Vit <- sum (distance) / (max (d.M$M.TEMPS)-min(d.M$M.TEMPS))
  M.VitTrueXY <- FALSE
  
  return (M.Vit)
}
  
