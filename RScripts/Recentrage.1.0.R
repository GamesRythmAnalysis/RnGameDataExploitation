# fonction de recentrage pour les donn√©es souris

# donneesouris <- d.M


recentrage <- function (donneesouris,infobaz) {
  # On slectionne les valeurs situes autour de la mediane
  xCenter <- median (d.M$M.XPOS)
  yCenter <- median (d.M$M.YPOS)
  
  #On suprime tout ce qui as ?t? captur? hors du jeu (a refaire on ne s'adapte pas a la r?gion de capture du jeu)
  seuils <- seq(10,50,by=10)
  i<-1
  SUB<- subset (d.M, d.M$M.XPOS < xCenter+seuils[i] & d.M$M.XPOS > xCenter-seuils[i]
                & d.M$M.YPOS < yCenter+seuils[i] & d.M$M.YPOS > yCenter-seuils[i])
  
  while(i<length(seuils) & length(SUB$M.XPOS)/length(d.M$M.XPOS)<0.85){
    SUB<- subset (d.M, d.M$M.XPOS < xCenter+seuils[i] & d.M$M.XPOS > xCenter-seuils[i]
                  & d.M$M.YPOS < yCenter+seuils[i] & d.M$M.YPOS > yCenter-seuils[i])
    i <- i +1
  }
  
  
  seuil<-seuils[i]
  # On replace tout sur un point zero ...
  # Qui n'est malheureusement jamais le vrai centre
  # Du fait de la drive de la distribution
  SUB$M.XPOS<-SUB$M.XPOS - xCenter
  SUB$M.YPOS<-SUB$M.YPOS - yCenter
  
  #on regarde les moment ou les deux coordone valent zeros =>recentrement + fin de movement du joueur
  zxy <- (SUB$M.XPOS == 0 & SUB$M.YPOS == 0)
  i<-1
  while(i<length(SUB$M.XPOS) & !zxy[i]){#on cherche la premiere fois ou ca arrive
    i<-i+1
  }
  
  #on s'assure que le premier element n'est pas un recentrage
  while(zxy[i+1]){
    i<-i+1
  }
  
  #on tronque les donnee pour commencer a un endroit bien propre
  SUB<-SUB[-(1:i),]
  zxy<-zxy[-(1:i)]
  
  Rxpos <- numeric(length(zxy)+1)
  Rypos <- numeric(length(zxy)+1)
  Zfol<-rep(TRUE,times=length(zxy)+1)
  
  #on recalcule les vecteur en prenant en compte les fin de mouvement des joueurs
  #et on cherche les fois ou il y as eux recentrage sans mouvement
  for(i in 1:length(zxy)){
    if (zxy[i]){
      Rxpos[i+1]<-SUB$M.XPOS[i]
      Rypos[i+1]<-SUB$M.YPOS[i]
      if(zxy[i-1]){
        Zfol[i]<-FALSE
      }
    }else{
      Rxpos[i+1]<-Rxpos[i]+SUB$M.XPOS[i]
      Rypos[i+1]<-Rypos[i]+SUB$M.YPOS[i]
    }
  }
  
  #on retire de la liste des mouvement les recentrage inutiles et le premier ?l?ment qui vaut 0
  SUB$M.XPOS<-Rxpos[-1]
  SUB$M.XPOS<-Rypos[-1]
  SUB<-SUB[Zfol,]
  zxy<-zxy[Zfol]
  
  #if(config$Graph & config$MouseGraph){
    
    s<-sample(length(Rxpos),length(Rxpos)/10)
    
    p<-data.frame(Rxpos[s],Rypos[s])
    names(p)<-c("XPOS","YPOS")
    
    graphiques.heatmap(p,XPOS,YPOS,
                       paste(infobaz,"\n","Mouvement de la Souris |seuil:",seuil),
                       paste (infobaz,".MM",".png", sep =""))
    
    graphiques.heatmap(p,XPOS,YPOS,
                       paste(infobaz,"\n","Mouvement de la Souris |seuil:",seuil),
                       paste (infobaz,".MMHO",".png", sep =""),
                       point = FALSE)
    
  #}
  
  distance=numeric(length(SUB$M.XPOS))
  
  #on calcule les distance pour la vitesse donc on ignore les movement de recentrage
  
  for(i in 0:(length(SUB$M.XPOS)-2)){
    if(zxy[i+1]){
      distance[i]<-0
    }else{
      distance[i]<-sqrt((SUB$M.XPOS[i+1]-SUB$M.XPOS[i])^2+(SUB$M.YPOS[i+1]-SUB$M.YPOS[i])^2)
    }
  }
  
  M.Vit <- sum (distance) / (max (d.M$M.TEMPS)-min(d.M$M.TEMPS))
  M.VitTrueXY <- FALSE
  
  return (M.Vit)
}
  
