# Analyse Souris
# Fonction pour analyse de la souris Rythmanalyse

GetMouseRythm<- function(click){
  
  clickUp<-paste(click," up",sep="")
  clickDown <-paste(click, " down",sep="")
  clickList<-subset (d.M, M.EVENEMENT == clickDown |  M.EVENEMENT == clickUp)
  
  Rez <- data.frame(down.time=numeric(),duration=numeric(),MouseClick=factor())
  down.time <-NULL
  
  if (nrow(clickList)>2) {
    
    for(i in 1:nrow(clickList)){
      #si on trouve l'evenement down on sauvegarde sont temps si il y as 2 down de suite on garde le nouveau
      if(clickList$M.EVENEMENT[i] == clickDown){
        down.time<-clickList$M.TEMPS[i]}
      
      if(clickList$M.EVENEMENT[i] == clickUp){
        
        if (is.null(down.time)){ #si il n'y as pas de down avant le up on set les variable a NA
          duration <- NA
          down.time <- NA
        } else {
          duration <- clickList$M.TEMPS[i] - down.time
        }
        #on concatene le tout et on reset down.time
        ligne <-c(down.time,duration)
        Rez <- rbind (Rez,ligne)
        down.time <-NULL
      }
    }
    
    Rez$MouseClick <- click  
  }
  
  
  names(Rez) <- c("down.time","duration","MouseClick")
  return(Rez)
  
}


AnalyseSouris <- function (d.M,infobaz,config) {
  
  # Nombre clics (distinguer droit et gauche) / repartion en % gauche
  d.McL <- subset (d.M, M.EVENEMENT == "mouse 1 down")
  d.McR <- subset (d.M, M.EVENEMENT == "mouse 2 down")
  d.Mc <- subset (d.M, M.EVENEMENT == "mouse 1 down" | M.EVENEMENT == "mouse 2 down")
  M.NbClics <- length (d.Mc$M.TEMPS)
  M.LR <- length (d.McL$M.TEMPS)/length (d.Mc$M.TEMPS) * 100 # pourcentage clic gauche
  
  d.Mscroll <- filter (d.M, M.EVENEMENT %in% c ("mouse scroll down", "mouse scroll up"))
  M.Scroll <- length (d.Mscroll)/(M.NbClics + length (d.Mscroll))*100 # pourcentage scroll
  
  # Duree secondes, minutes activite souris
  M.DuS <- max (d.M$M.TEMPS) - min (d.M$M.TEMPS)
  M.DuM <- M.DuS / 60
  
  # Nombre clics par seconde
  M.NbCliclsS <- M.NbClics / M.DuS
  
  # Temps entre deux clics et ecart-type
  M.TpEntreAppuis <- d.Mc$M.TEMPS[2:length(d.Mc$M.TEMPS)]-d.Mc$M.TEMPS[1:length(d.Mc$M.TEMPS)-1]
  M.TpMoyEntreAppuis <- mean ( M.TpEntreAppuis)
  M.TpSDEntreAppuis <- sd (M.TpEntreAppuis)
  
  #Duree reel d'activite des clicks duree moyen des click
  mouse_L_rythm <- GetMouseRythm("mouse 1")
  mouse_R_rythm <- GetMouseRythm("mouse 2")
  M.TpsClickR<- sum(mouse_R_rythm$duration,na.rm=TRUE)
  M.TpsClickL<- sum(mouse_L_rythm$duration,na.rm=TRUE)
  M.TpsTotClick <- M.TpsClickL + M.TpsClickR
  M.MoyTpsClickR <- mean(mouse_R_rythm$duration,na.rm=TRUE)
  M.SDTpsClickR <- sd(mouse_R_rythm$duration,na.rm=TRUE)
  M.MoyTpsClickL <- mean(mouse_L_rythm$duration,na.rm=TRUE)
  M.SDTpsClickL <- sd(mouse_L_rythm$duration,na.rm=TRUE)
  
  if(config$Graph & config$MouseGraph){
    d.MnoMov <- filter (d.M, M.EVENEMENT %in% c("mouse 1 down", "mouse 2 down", "mouse scroll down", "mouse scroll up"))
    
    ggplot(data = d.MnoMov, aes(M.TEMPS, fill = M.EVENEMENT)) +
      geom_area (stat="bin", binwidth = M.DuM*3, position = "stack", linetype = 1, size = 0.8, colour ="black") +
      xlab ("Temps (s)") +
      ylab ("Appuis") +
      ggtitle (label = "Frequence des click | binwidth variable",
               subtitle = infobaz) +
      scale_fill_brewer("MouseClick", palette="Set1")+
      theme_classic()
    ggsave(filename = paste (infobaz,".MF",".png", sep =""), width = 15, height = 7)
  }
  
  # On determine s'il y a recentrage
  cond1 <- fivenum(d.M$M.XPOS)[4]-fivenum(d.M$M.XPOS)[2]
  cond2 <- fivenum(d.M$M.YPOS)[4]-fivenum(d.M$M.YPOS)[2]
  
  if (cond1 > 20 & cond2 > 20) { # On teste si donnees mouvement souris ne sont pas bugges
    DifX <- (d.M$M.XPOS[2:length(d.M$M.XPOS)] - d.M$M.XPOS[1:length(d.M$M.XPOS)-1])
    DifY <- d.M$M.YPOS[2:length(d.M$M.YPOS)] - d.M$M.YPOS[1:length(d.M$M.YPOS)-1]
    M.Vit <- sum (sqrt (DifX^2 +DifY^2)) / max (d.M$M.TEMPS)
    M.VitTrueXY <- TRUE
    
    if(config$Graph & config$MouseGraph){
      d2sampl <- d.M[sample(nrow(d.M), (nrow(d.M)/10)), ]
      
      ggplot (d2sampl,aes (x=-M.XPOS, y=-M.YPOS)) +
        geom_point(colour ="lightblue", alpha =0.25) +
        stat_density2d(aes(alpha = ..level.., fill=..level..), bins = 15, geom = "polygon")+
        scale_alpha_continuous(guide = FALSE)+
        scale_fill_gradient(low = "green", high = "red") +
        geom_density2d (colour="black", bins = 15, alpha = 0.25) + 
        ggtitle(paste(infobaz,"\n","Mouvement Souris"))
      ggsave (file = paste (infobaz,".M.map",".png", sep =""),
              width = 150, height = 125, units = "mm")
    }
  } else {
    
    # On slectionne les valeurs situes autour de la mediane
    xCenter <- median (d.M$M.XPOS)
    yCenter <- median (d.M$M.YPOS)
    
    #On suprime tout ce qui as été capturé hors du jeu (a refaire on ne s'adapte pas a la région de capture du jeu)
    seuils <- seq(10,50,by=10)
    i<-1
    SUB<- subset (d.M, d.M$M.XPOS < xCenter+seuils[i] & d.M$M.XPOS > xCenter-seuils[i]
                  & d.M$M.YPOS < yCenter+seuils[i] & d.M$M.YPOS > yCenter-seuils[i])
    
    while(i<length(seuils) & length(SUB$M.XPOS)/length(d.M$M.XPOS)<0.85){
      SUB<- subset (d.M, d.M$M.XPOS < xCenter+seuils[i] & d.M$M.XPOS > xCenter-seuils[i]
                    & d.M$M.YPOS < yCenter+seuils[i] & d.M$M.YPOS > yCenter-seuils[i])
    }

    # On replace tout sur un point zero ...
    # Qui n'est malheureusement jamais le vrai centre
    # Du fait de la drive de la distribution
    SUB$M.XPOS<-SUB$M.XPOS - xCenter
    SUB$M.YPOS<-SUB$M.YPOS - yCenter
    
    #on regarde les moment ou les deux coordoné valent zéros =>recentrement + fin de movement du joueur
    zxy <- (SUB$M.XPOS == 0 & SUB$M.YPOS == 0)
    i<-1
    while(i<length(SUB$M.XPOS) & !zxy[i]){#on cherche la première fois ou ça arrive
      i<-i+1
    }
    #on tronque les donné pour commencer a un endroit bien propre
    
    SUB<-SUB[-(1:i),]
    zxy<-zxy[-(1:i)]
    
    Rxpos <- numeric(length(zxy)+1)
    Rypos <- numeric(length(zxy)+1)
    Zfol<-rep(TRUE,times=length(zxy)+1)
    
    #on recalcule les vecteur en prenant en compte les fin de mouvement des joueurs
    #et on cherche les fois ou il y as eux recentrage sans mouvement
    for(i in 1:length(zxy)){
      if (zxy[i]){
        Rxpos[i+1]<-SUB$M.XPOS[i]
        Rypos[i+1]<-SUB$M.YPOS[i]
        if(zxy[i-1]){
          Zfol[i]<-FALSE
        }
      }else{
        Rxpos[i+1]<-Rxpos[i]+SUB$M.XPOS[i]
        Rypos[i+1]<-Rypos[i]+SUB$M.YPOS[i]
      }
    }
    #on retire de la liste des mouvement les recentrage inutiles et le premier élément qui vaut 0
    
    SUB$M.XPOS<-Rxpos[-1]
    SUB$M.XPOS<-Rypos[-1]
    SUB<-SUB[Zfol,]
    zxy<-zxy[Zfol]
    
    if(config$Graph & config$MouseGraph){
      
      s<-sample(length(Rxpos),length(Rxpos)/10)
      
      p<-data.frame(Rxpos[s],Rypos[s])
      names(p)<-c("XPOS","YPOS")
      
      ggplot (p,aes (x=XPOS, y=YPOS)) +
        geom_point(colour ="lightblue", alpha =0.25) +
        stat_density2d(aes(alpha = ..level.., fill=..level..), bins = 15, geom = "polygon")+
        scale_alpha_continuous(guide = FALSE)+
        scale_fill_gradient(low = "green", high = "red") +
        geom_density2d (colour="black", bins = 15, alpha = 0.25)+
        ggtitle(paste(infobaz,"\n","Mouvement de la Souris |seuil:",seuil))
      
      ggsave (file = paste (infobaz,".MM",".png", sep =""),
              width = 125, height = 125, units = "mm")
      
      ggplot (p,aes (x=XPOS, y=YPOS)) +
        stat_density2d(aes(alpha = ..level.., fill=..level..), bins = 15, geom = "polygon")+
        scale_alpha_continuous(guide = FALSE)+
        scale_fill_gradient(low = "green", high = "red") +
        geom_density2d (colour="black", bins = 15, alpha = 0.25)+
        ggtitle(paste(infobaz,"\n","Mouvement de la Souris|seuil:",seuil))
      
      ggsave (file = paste (infobaz,".MMHO",".png", sep =""),
              width = 125, height = 125, units = "mm")
    
    }
    distance=numeric(length(SUB$M.XPOS))
    
    #on calcule les distance pour la vitesse donc on ignore les movement de recentrage
    
    for(i in 0:(length(SUB$M.XPOS)-2)){
      if(zxy[i+1]){
        distance[i]<-0
      }else{
        distance[i]<-sqrt((SUB$M.XPOS[i+1]-SUB$M.XPOS[i])^2+(SUB$M.YPOS[i+1]-SUB$M.YPOS[i])^2)
      }
    }
    
    M.Vit <- sum (distance) / (max (d.M$M.TEMPS)-min(d.M$M.TEMPS))
    M.VitTrueXY <- FALSE
    
  }
  
  #M.DuM # Duree activite souris en minutes
  #M.NbClics # Nombre total d'appuis
  #M.NbCliclsS # Clics par seconde
  #M.TpsClickR #Temps cumuler a faire click droit
  #M.TpsClickL #Temps cumuler a faire click gauche 
  #M.TpsTotClick #Temps Cumuler a clicker
  #M.MoyTpsClickR #Temps moyen d'un click droit
  #M.SDTpsClickR #Ecart type du temps d'un click droit
  #M.MoyTpsClickL #Temps moyen d'un click gauche
  #M.SDTpsClickL #Ecart type du temps d'un click gauche
  #M.LR # Pourcentage de clics gauche
  #M.TpMoyEntreAppuis # Temps moyen entre deux appuis
  #M.TpSDEntreAppuis # Ecart type entre deux appuis
  #M.Vit # Moyenne des vitesses instantanes
  #M.VitTrueXY #si la vitesse est calculer a partir des vraie coordonnée ou après une modification
  
  resultats <- data.frame(M.DuM,M.NbClics,M.NbCliclsS,
                          M.TpsClickR,M.TpsClickL,
                          M.TpsTotClick,M.MoyTpsClickR,
                          M.SDTpsClickR,M.MoyTpsClickL,M.SDTpsClickL,
                          M.LR, M.Scroll,
                          M.TpMoyEntreAppuis,M.TpSDEntreAppuis,
                          M.Vit,M.VitTrueXY)
  return (resultats)
}